{"ast":null,"code":"import { getStreamContents } from './contents.js';\nimport { noop, throwObjectStream, getLengthProperty } from './utils.js';\nexport async function getStreamAsArrayBuffer(stream, options) {\n  return getStreamContents(stream, arrayBufferMethods, options);\n}\nconst initArrayBuffer = () => ({\n  contents: new ArrayBuffer(0)\n});\nconst useTextEncoder = chunk => textEncoder.encode(chunk);\nconst textEncoder = new TextEncoder();\nconst useUint8Array = chunk => new Uint8Array(chunk);\nconst useUint8ArrayWithOffset = chunk => new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);\nconst truncateArrayBufferChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);\n\n// `contents` is an increasingly growing `Uint8Array`.\nconst addArrayBufferChunk = (convertedChunk, _ref, length) => {\n  let {\n    contents,\n    length: previousLength\n  } = _ref;\n  const newContents = hasArrayBufferResize() ? resizeArrayBuffer(contents, length) : resizeArrayBufferSlow(contents, length);\n  new Uint8Array(newContents).set(convertedChunk, previousLength);\n  return newContents;\n};\n\n// Without `ArrayBuffer.resize()`, `contents` size is always a power of 2.\n// This means its last bytes are zeroes (not stream data), which need to be\n// trimmed at the end with `ArrayBuffer.slice()`.\nconst resizeArrayBufferSlow = (contents, length) => {\n  if (length <= contents.byteLength) {\n    return contents;\n  }\n  const arrayBuffer = new ArrayBuffer(getNewContentsLength(length));\n  new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);\n  return arrayBuffer;\n};\n\n// With `ArrayBuffer.resize()`, `contents` size matches exactly the size of\n// the stream data. It does not include extraneous zeroes to trim at the end.\n// The underlying `ArrayBuffer` does allocate a number of bytes that is a power\n// of 2, but those bytes are only visible after calling `ArrayBuffer.resize()`.\nconst resizeArrayBuffer = (contents, length) => {\n  if (length <= contents.maxByteLength) {\n    contents.resize(length);\n    return contents;\n  }\n  const arrayBuffer = new ArrayBuffer(length, {\n    maxByteLength: getNewContentsLength(length)\n  });\n  new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);\n  return arrayBuffer;\n};\n\n// Retrieve the closest `length` that is both >= and a power of 2\nconst getNewContentsLength = length => SCALE_FACTOR ** Math.ceil(Math.log(length) / Math.log(SCALE_FACTOR));\nconst SCALE_FACTOR = 2;\nconst finalizeArrayBuffer = _ref2 => {\n  let {\n    contents,\n    length\n  } = _ref2;\n  return hasArrayBufferResize() ? contents : contents.slice(0, length);\n};\n\n// `ArrayBuffer.slice()` is slow. When `ArrayBuffer.resize()` is available\n// (Node >=20.0.0, Safari >=16.4 and Chrome), we can use it instead.\n// eslint-disable-next-line no-warning-comments\n// TODO: remove after dropping support for Node 20.\n// eslint-disable-next-line no-warning-comments\n// TODO: use `ArrayBuffer.transferToFixedLength()` instead once it is available\nconst hasArrayBufferResize = () => 'resize' in ArrayBuffer.prototype;\nconst arrayBufferMethods = {\n  init: initArrayBuffer,\n  convertChunk: {\n    string: useTextEncoder,\n    buffer: useUint8Array,\n    arrayBuffer: useUint8Array,\n    dataView: useUint8ArrayWithOffset,\n    typedArray: useUint8ArrayWithOffset,\n    others: throwObjectStream\n  },\n  getSize: getLengthProperty,\n  truncateChunk: truncateArrayBufferChunk,\n  addChunk: addArrayBufferChunk,\n  getFinalChunk: noop,\n  finalize: finalizeArrayBuffer\n};","map":{"version":3,"names":["getStreamContents","noop","throwObjectStream","getLengthProperty","getStreamAsArrayBuffer","stream","options","arrayBufferMethods","initArrayBuffer","contents","ArrayBuffer","useTextEncoder","chunk","textEncoder","encode","TextEncoder","useUint8Array","Uint8Array","useUint8ArrayWithOffset","buffer","byteOffset","byteLength","truncateArrayBufferChunk","convertedChunk","chunkSize","slice","addArrayBufferChunk","_ref","length","previousLength","newContents","hasArrayBufferResize","resizeArrayBuffer","resizeArrayBufferSlow","set","arrayBuffer","getNewContentsLength","maxByteLength","resize","SCALE_FACTOR","Math","ceil","log","finalizeArrayBuffer","_ref2","prototype","init","convertChunk","string","dataView","typedArray","others","getSize","truncateChunk","addChunk","getFinalChunk","finalize"],"sources":["C:/Users/sakas/OneDrive/Desktop/gogo/node_modules/cacheable-request/node_modules/get-stream/source/array-buffer.js"],"sourcesContent":["import {getStreamContents} from './contents.js';\nimport {noop, throwObjectStream, getLengthProperty} from './utils.js';\n\nexport async function getStreamAsArrayBuffer(stream, options) {\n\treturn getStreamContents(stream, arrayBufferMethods, options);\n}\n\nconst initArrayBuffer = () => ({contents: new ArrayBuffer(0)});\n\nconst useTextEncoder = chunk => textEncoder.encode(chunk);\nconst textEncoder = new TextEncoder();\n\nconst useUint8Array = chunk => new Uint8Array(chunk);\n\nconst useUint8ArrayWithOffset = chunk => new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n\nconst truncateArrayBufferChunk = (convertedChunk, chunkSize) => convertedChunk.slice(0, chunkSize);\n\n// `contents` is an increasingly growing `Uint8Array`.\nconst addArrayBufferChunk = (convertedChunk, {contents, length: previousLength}, length) => {\n\tconst newContents = hasArrayBufferResize() ? resizeArrayBuffer(contents, length) : resizeArrayBufferSlow(contents, length);\n\tnew Uint8Array(newContents).set(convertedChunk, previousLength);\n\treturn newContents;\n};\n\n// Without `ArrayBuffer.resize()`, `contents` size is always a power of 2.\n// This means its last bytes are zeroes (not stream data), which need to be\n// trimmed at the end with `ArrayBuffer.slice()`.\nconst resizeArrayBufferSlow = (contents, length) => {\n\tif (length <= contents.byteLength) {\n\t\treturn contents;\n\t}\n\n\tconst arrayBuffer = new ArrayBuffer(getNewContentsLength(length));\n\tnew Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);\n\treturn arrayBuffer;\n};\n\n// With `ArrayBuffer.resize()`, `contents` size matches exactly the size of\n// the stream data. It does not include extraneous zeroes to trim at the end.\n// The underlying `ArrayBuffer` does allocate a number of bytes that is a power\n// of 2, but those bytes are only visible after calling `ArrayBuffer.resize()`.\nconst resizeArrayBuffer = (contents, length) => {\n\tif (length <= contents.maxByteLength) {\n\t\tcontents.resize(length);\n\t\treturn contents;\n\t}\n\n\tconst arrayBuffer = new ArrayBuffer(length, {maxByteLength: getNewContentsLength(length)});\n\tnew Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);\n\treturn arrayBuffer;\n};\n\n// Retrieve the closest `length` that is both >= and a power of 2\nconst getNewContentsLength = length => SCALE_FACTOR ** Math.ceil(Math.log(length) / Math.log(SCALE_FACTOR));\n\nconst SCALE_FACTOR = 2;\n\nconst finalizeArrayBuffer = ({contents, length}) => hasArrayBufferResize() ? contents : contents.slice(0, length);\n\n// `ArrayBuffer.slice()` is slow. When `ArrayBuffer.resize()` is available\n// (Node >=20.0.0, Safari >=16.4 and Chrome), we can use it instead.\n// eslint-disable-next-line no-warning-comments\n// TODO: remove after dropping support for Node 20.\n// eslint-disable-next-line no-warning-comments\n// TODO: use `ArrayBuffer.transferToFixedLength()` instead once it is available\nconst hasArrayBufferResize = () => 'resize' in ArrayBuffer.prototype;\n\nconst arrayBufferMethods = {\n\tinit: initArrayBuffer,\n\tconvertChunk: {\n\t\tstring: useTextEncoder,\n\t\tbuffer: useUint8Array,\n\t\tarrayBuffer: useUint8Array,\n\t\tdataView: useUint8ArrayWithOffset,\n\t\ttypedArray: useUint8ArrayWithOffset,\n\t\tothers: throwObjectStream,\n\t},\n\tgetSize: getLengthProperty,\n\ttruncateChunk: truncateArrayBufferChunk,\n\taddChunk: addArrayBufferChunk,\n\tgetFinalChunk: noop,\n\tfinalize: finalizeArrayBuffer,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}