{"ast":null,"code":"import _objectSpread from \"C:/Users/sakas/OneDrive/Desktop/gogo/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncGeneratorDelegate from \"C:/Users/sakas/OneDrive/Desktop/gogo/node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate.js\";\nimport _asyncIterator from \"C:/Users/sakas/OneDrive/Desktop/gogo/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport _awaitAsyncGenerator from \"C:/Users/sakas/OneDrive/Desktop/gogo/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js\";\nimport _wrapAsyncGenerator from \"C:/Users/sakas/OneDrive/Desktop/gogo/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js\";\nvar __typeError = msg => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\n\n// src/util/chunk.ts\nvar MAX_CHUNK_SIZE = 65536;\nfunction* chunk(value) {\n  if (value.byteLength <= MAX_CHUNK_SIZE) {\n    yield value;\n    return;\n  }\n  let offset = 0;\n  while (offset < value.byteLength) {\n    const size = Math.min(value.byteLength - offset, MAX_CHUNK_SIZE);\n    const buffer = value.buffer.slice(offset, offset + size);\n    offset += buffer.byteLength;\n    yield new Uint8Array(buffer);\n  }\n}\n\n// src/util/createBoundary.ts\nvar alphabet = \"abcdefghijklmnopqrstuvwxyz0123456789\";\nfunction createBoundary() {\n  let size = 16;\n  let res = \"\";\n  while (size--) {\n    res += alphabet[Math.random() * alphabet.length << 0];\n  }\n  return res;\n}\n\n// src/util/escapeName.ts\nvar escapeName = name => String(name).replace(/\\r/g, \"%0D\").replace(/\\n/g, \"%0A\").replace(/\"/g, \"%22\");\n\n// src/util/isFunction.ts\nvar isFunction = value => typeof value === \"function\";\n\n// src/util/isReadableStreamFallback.ts\nvar isReadableStreamFallback = value => !!value && typeof value === \"object\" && !Array.isArray(value) && isFunction(value.getReader);\n\n// src/util/isAsyncIterable.ts\nvar isAsyncIterable = value => isFunction(value[Symbol.asyncIterator]);\n\n// src/util/getStreamIterator.ts\nfunction readStream(_x) {\n  return _readStream.apply(this, arguments);\n}\nfunction _readStream() {\n  _readStream = _wrapAsyncGenerator(function* (readable) {\n    const reader = readable.getReader();\n    while (true) {\n      const {\n        done,\n        value\n      } = yield _awaitAsyncGenerator(reader.read());\n      if (done) {\n        break;\n      }\n      yield value;\n    }\n  });\n  return _readStream.apply(this, arguments);\n}\nfunction chunkStream(_x2) {\n  return _chunkStream.apply(this, arguments);\n}\nfunction _chunkStream() {\n  _chunkStream = _wrapAsyncGenerator(function* (stream) {\n    var _iteratorAbruptCompletion = false;\n    var _didIteratorError = false;\n    var _iteratorError;\n    try {\n      for (var _iterator = _asyncIterator(stream), _step; _iteratorAbruptCompletion = !(_step = yield _awaitAsyncGenerator(_iterator.next())).done; _iteratorAbruptCompletion = false) {\n        const value = _step.value;\n        {\n          yield* _asyncGeneratorDelegate(_asyncIterator(chunk(value)), _awaitAsyncGenerator);\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion && _iterator.return != null) {\n          yield _awaitAsyncGenerator(_iterator.return());\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n  });\n  return _chunkStream.apply(this, arguments);\n}\nvar getStreamIterator = source => {\n  if (isAsyncIterable(source)) {\n    return chunkStream(source);\n  }\n  if (isReadableStreamFallback(source)) {\n    return chunkStream(readStream(source));\n  }\n  throw new TypeError(\"Unsupported data source: Expected either ReadableStream or async iterable.\");\n};\n\n// src/util/isFile.ts\nvar isFile = value => Boolean(value && typeof value === \"object\" && isFunction(value.constructor) && value[Symbol.toStringTag] === \"File\" && isFunction(value.stream) && value.name != null);\n\n// src/util/isFormData.ts\nvar isFormData = value => Boolean(value && isFunction(value.constructor) && value[Symbol.toStringTag] === \"FormData\" && isFunction(value.append) && isFunction(value.getAll) && isFunction(value.entries) && isFunction(value[Symbol.iterator]));\n\n// src/util/isPlainObject.ts\nvar getType = value => Object.prototype.toString.call(value).slice(8, -1).toLowerCase();\nfunction isPlainObject(value) {\n  var _pp$constructor, _pp$constructor$toStr;\n  if (getType(value) !== \"object\") {\n    return false;\n  }\n  const pp = Object.getPrototypeOf(value);\n  if (pp === null || pp === void 0) {\n    return true;\n  }\n  return ((_pp$constructor = pp.constructor) === null || _pp$constructor === void 0 || (_pp$constructor$toStr = _pp$constructor.toString) === null || _pp$constructor$toStr === void 0 ? void 0 : _pp$constructor$toStr.call(_pp$constructor)) === Object.toString();\n}\n\n// src/util/normalizeValue.ts\nvar normalizeValue = value => String(value).replace(/\\r|\\n/g, (match, i, str) => {\n  if (match === \"\\r\" && str[i + 1] !== \"\\n\" || match === \"\\n\" && str[i - 1] !== \"\\r\") {\n    return \"\\r\\n\";\n  }\n  return match;\n});\n\n// src/util/proxyHeaders.ts\nfunction getProperty(target, prop) {\n  if (typeof prop === \"string\") {\n    for (const [name, value] of Object.entries(target)) {\n      if (prop.toLowerCase() === name.toLowerCase()) {\n        return value;\n      }\n    }\n  }\n  return void 0;\n}\nvar proxyHeaders = object => new Proxy(object, {\n  get: (target, prop) => getProperty(target, prop),\n  has: (target, prop) => getProperty(target, prop) !== void 0\n});\n\n// src/FormDataEncoder.ts\nvar defaultOptions = {\n  enableAdditionalHeaders: false\n};\nvar readonlyProp = {\n  writable: false,\n  configurable: false\n};\nvar _CRLF, _CRLF_BYTES, _CRLF_BYTES_LENGTH, _DASHES, _encoder, _footer, _form, _options, _FormDataEncoder_instances, getFieldHeader_fn, getContentLength_fn;\nvar FormDataEncoder = class {\n  constructor(form, boundaryOrOptions, options) {\n    __privateAdd(this, _FormDataEncoder_instances);\n    __privateAdd(this, _CRLF, \"\\r\\n\");\n    __privateAdd(this, _CRLF_BYTES);\n    __privateAdd(this, _CRLF_BYTES_LENGTH);\n    __privateAdd(this, _DASHES, \"-\".repeat(2));\n    /**\n     * TextEncoder instance\n     */\n    __privateAdd(this, _encoder, new TextEncoder());\n    /**\n     * Returns form-data footer bytes\n     */\n    __privateAdd(this, _footer);\n    /**\n     * FormData instance\n     */\n    __privateAdd(this, _form);\n    /**\n     * Instance options\n     */\n    __privateAdd(this, _options);\n    if (!isFormData(form)) {\n      throw new TypeError(\"Expected first argument to be a FormData instance.\");\n    }\n    let boundary;\n    if (isPlainObject(boundaryOrOptions)) {\n      options = boundaryOrOptions;\n    } else {\n      boundary = boundaryOrOptions;\n    }\n    if (!boundary) {\n      boundary = \"form-data-encoder-\".concat(createBoundary());\n    }\n    if (typeof boundary !== \"string\") {\n      throw new TypeError(\"Expected boundary argument to be a string.\");\n    }\n    if (options && !isPlainObject(options)) {\n      throw new TypeError(\"Expected options argument to be an object.\");\n    }\n    __privateSet(this, _form, Array.from(form.entries()));\n    __privateSet(this, _options, _objectSpread(_objectSpread({}, defaultOptions), options));\n    __privateSet(this, _CRLF_BYTES, __privateGet(this, _encoder).encode(__privateGet(this, _CRLF)));\n    __privateSet(this, _CRLF_BYTES_LENGTH, __privateGet(this, _CRLF_BYTES).byteLength);\n    this.boundary = boundary;\n    this.contentType = \"multipart/form-data; boundary=\".concat(this.boundary);\n    __privateSet(this, _footer, __privateGet(this, _encoder).encode(\"\".concat(__privateGet(this, _DASHES)).concat(this.boundary).concat(__privateGet(this, _DASHES)).concat(__privateGet(this, _CRLF).repeat(2))));\n    const headers = {\n      \"Content-Type\": this.contentType\n    };\n    const contentLength = __privateMethod(this, _FormDataEncoder_instances, getContentLength_fn).call(this);\n    if (contentLength) {\n      this.contentLength = contentLength;\n      headers[\"Content-Length\"] = contentLength;\n    }\n    this.headers = proxyHeaders(Object.freeze(headers));\n    Object.defineProperties(this, {\n      boundary: readonlyProp,\n      contentType: readonlyProp,\n      contentLength: readonlyProp,\n      headers: readonlyProp\n    });\n  }\n  /**\n   * Creates an iterator allowing to go through form-data parts (with metadata).\n   * This method **will not** read the files and **will not** split values big into smaller chunks.\n   *\n   * Using this method, you can convert form-data content into Blob:\n   *\n   * @example\n   *\n   * ```ts\n   * import {Readable} from \"stream\"\n   *\n   * import {FormDataEncoder} from \"form-data-encoder\"\n   *\n   * import {FormData} from \"formdata-polyfill/esm-min.js\"\n   * import {fileFrom} from \"fetch-blob/form.js\"\n   * import {File} from \"fetch-blob/file.js\"\n   * import {Blob} from \"fetch-blob\"\n   *\n   * import fetch from \"node-fetch\"\n   *\n   * const form = new FormData()\n   *\n   * form.set(\"field\", \"Just a random string\")\n   * form.set(\"file\", new File([\"Using files is class amazing\"]))\n   * form.set(\"fileFromPath\", await fileFrom(\"path/to/a/file.txt\"))\n   *\n   * const encoder = new FormDataEncoder(form)\n   *\n   * const options = {\n   *   method: \"post\",\n   *   body: new Blob(encoder, {type: encoder.contentType})\n   * }\n   *\n   * const response = await fetch(\"https://httpbin.org/post\", options)\n   *\n   * console.log(await response.json())\n   * ```\n   */\n  *values() {\n    for (const [name, raw] of __privateGet(this, _form)) {\n      const value = isFile(raw) ? raw : __privateGet(this, _encoder).encode(normalizeValue(raw));\n      yield __privateMethod(this, _FormDataEncoder_instances, getFieldHeader_fn).call(this, name, value);\n      yield value;\n      yield __privateGet(this, _CRLF_BYTES);\n    }\n    yield __privateGet(this, _footer);\n  }\n  /**\n   * Creates an async iterator allowing to perform the encoding by portions.\n   * This method reads through files and splits big values into smaller pieces (65536 bytes per each).\n   *\n   * @example\n   *\n   * ```ts\n   * import {Readable} from \"stream\"\n   *\n   * import {FormData, File, fileFromPath} from \"formdata-node\"\n   * import {FormDataEncoder} from \"form-data-encoder\"\n   *\n   * import fetch from \"node-fetch\"\n   *\n   * const form = new FormData()\n   *\n   * form.set(\"field\", \"Just a random string\")\n   * form.set(\"file\", new File([\"Using files is class amazing\"], \"file.txt\"))\n   * form.set(\"fileFromPath\", await fileFromPath(\"path/to/a/file.txt\"))\n   *\n   * const encoder = new FormDataEncoder(form)\n   *\n   * const options = {\n   *   method: \"post\",\n   *   headers: encoder.headers,\n   *   body: Readable.from(encoder.encode()) // or Readable.from(encoder)\n   * }\n   *\n   * const response = await fetch(\"https://httpbin.org/post\", options)\n   *\n   * console.log(await response.json())\n   * ```\n   */\n  encode() {\n    var _this = this;\n    return _wrapAsyncGenerator(function* () {\n      for (const part of _this.values()) {\n        if (isFile(part)) {\n          yield* _asyncGeneratorDelegate(_asyncIterator(getStreamIterator(part.stream())), _awaitAsyncGenerator);\n        } else {\n          yield* _asyncGeneratorDelegate(_asyncIterator(chunk(part)), _awaitAsyncGenerator);\n        }\n      }\n    })();\n  }\n  /**\n   * Creates an iterator allowing to read through the encoder data using for...of loops\n   */\n  [Symbol.iterator]() {\n    return this.values();\n  }\n  /**\n   * Creates an **async** iterator allowing to read through the encoder data using for-await...of loops\n   */\n  [Symbol.asyncIterator]() {\n    return this.encode();\n  }\n};\n_CRLF = new WeakMap();\n_CRLF_BYTES = new WeakMap();\n_CRLF_BYTES_LENGTH = new WeakMap();\n_DASHES = new WeakMap();\n_encoder = new WeakMap();\n_footer = new WeakMap();\n_form = new WeakMap();\n_options = new WeakMap();\n_FormDataEncoder_instances = new WeakSet();\ngetFieldHeader_fn = function (name, value) {\n  let header = \"\";\n  header += \"\".concat(__privateGet(this, _DASHES)).concat(this.boundary).concat(__privateGet(this, _CRLF));\n  header += \"Content-Disposition: form-data; name=\\\"\".concat(escapeName(name), \"\\\"\");\n  if (isFile(value)) {\n    header += \"; filename=\\\"\".concat(escapeName(value.name), \"\\\"\").concat(__privateGet(this, _CRLF));\n    header += \"Content-Type: \".concat(value.type || \"application/octet-stream\");\n  }\n  if (__privateGet(this, _options).enableAdditionalHeaders === true) {\n    const size = isFile(value) ? value.size : value.byteLength;\n    if (size != null && !isNaN(size)) {\n      header += \"\".concat(__privateGet(this, _CRLF), \"Content-Length: \").concat(size);\n    }\n  }\n  return __privateGet(this, _encoder).encode(\"\".concat(header).concat(__privateGet(this, _CRLF).repeat(2)));\n};\n/**\n * Returns form-data content length\n */\ngetContentLength_fn = function () {\n  let length = 0;\n  for (const [name, raw] of __privateGet(this, _form)) {\n    const value = isFile(raw) ? raw : __privateGet(this, _encoder).encode(normalizeValue(raw));\n    const size = isFile(value) ? value.size : value.byteLength;\n    if (size == null || isNaN(size)) {\n      return void 0;\n    }\n    length += __privateMethod(this, _FormDataEncoder_instances, getFieldHeader_fn).call(this, name, value).byteLength;\n    length += size;\n    length += __privateGet(this, _CRLF_BYTES_LENGTH);\n  }\n  return String(length + __privateGet(this, _footer).byteLength);\n};\nexport { FormDataEncoder, isFile, isFormData };","map":{"version":3,"names":["__typeError","msg","TypeError","__accessCheck","obj","member","has","__privateGet","getter","call","get","__privateAdd","value","WeakSet","add","set","__privateSet","setter","__privateMethod","method","MAX_CHUNK_SIZE","chunk","byteLength","offset","size","Math","min","buffer","slice","Uint8Array","alphabet","createBoundary","res","random","length","escapeName","name","String","replace","isFunction","isReadableStreamFallback","Array","isArray","getReader","isAsyncIterable","Symbol","asyncIterator","readStream","_x","_readStream","apply","arguments","_wrapAsyncGenerator","readable","reader","done","_awaitAsyncGenerator","read","chunkStream","_x2","_chunkStream","stream","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_asyncIterator","_step","next","_asyncGeneratorDelegate","err","return","getStreamIterator","source","isFile","Boolean","constructor","toStringTag","isFormData","append","getAll","entries","iterator","getType","Object","prototype","toString","toLowerCase","isPlainObject","_pp$constructor","_pp$constructor$toStr","pp","getPrototypeOf","normalizeValue","match","i","str","getProperty","target","prop","proxyHeaders","object","Proxy","defaultOptions","enableAdditionalHeaders","readonlyProp","writable","configurable","_CRLF","_CRLF_BYTES","_CRLF_BYTES_LENGTH","_DASHES","_encoder","_footer","_form","_options","_FormDataEncoder_instances","getFieldHeader_fn","getContentLength_fn","FormDataEncoder","form","boundaryOrOptions","options","repeat","TextEncoder","boundary","concat","from","_objectSpread","encode","contentType","headers","contentLength","freeze","defineProperties","values","raw","_this","part","WeakMap","header","type","isNaN"],"sources":["C:/Users/sakas/OneDrive/Desktop/gogo/node_modules/form-data-encoder/lib/index.js"],"sourcesContent":["var __typeError = (msg) => {\n  throw TypeError(msg);\n};\nvar __accessCheck = (obj, member, msg) => member.has(obj) || __typeError(\"Cannot \" + msg);\nvar __privateGet = (obj, member, getter) => (__accessCheck(obj, member, \"read from private field\"), getter ? getter.call(obj) : member.get(obj));\nvar __privateAdd = (obj, member, value) => member.has(obj) ? __typeError(\"Cannot add the same private member more than once\") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\nvar __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, \"write to private field\"), setter ? setter.call(obj, value) : member.set(obj, value), value);\nvar __privateMethod = (obj, member, method) => (__accessCheck(obj, member, \"access private method\"), method);\n\n// src/util/chunk.ts\nvar MAX_CHUNK_SIZE = 65536;\nfunction* chunk(value) {\n  if (value.byteLength <= MAX_CHUNK_SIZE) {\n    yield value;\n    return;\n  }\n  let offset = 0;\n  while (offset < value.byteLength) {\n    const size = Math.min(value.byteLength - offset, MAX_CHUNK_SIZE);\n    const buffer = value.buffer.slice(offset, offset + size);\n    offset += buffer.byteLength;\n    yield new Uint8Array(buffer);\n  }\n}\n\n// src/util/createBoundary.ts\nvar alphabet = \"abcdefghijklmnopqrstuvwxyz0123456789\";\nfunction createBoundary() {\n  let size = 16;\n  let res = \"\";\n  while (size--) {\n    res += alphabet[Math.random() * alphabet.length << 0];\n  }\n  return res;\n}\n\n// src/util/escapeName.ts\nvar escapeName = (name) => String(name).replace(/\\r/g, \"%0D\").replace(/\\n/g, \"%0A\").replace(/\"/g, \"%22\");\n\n// src/util/isFunction.ts\nvar isFunction = (value) => typeof value === \"function\";\n\n// src/util/isReadableStreamFallback.ts\nvar isReadableStreamFallback = (value) => !!value && typeof value === \"object\" && !Array.isArray(value) && isFunction(value.getReader);\n\n// src/util/isAsyncIterable.ts\nvar isAsyncIterable = (value) => isFunction(value[Symbol.asyncIterator]);\n\n// src/util/getStreamIterator.ts\nasync function* readStream(readable) {\n  const reader = readable.getReader();\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    yield value;\n  }\n}\nasync function* chunkStream(stream) {\n  for await (const value of stream) {\n    yield* chunk(value);\n  }\n}\nvar getStreamIterator = (source) => {\n  if (isAsyncIterable(source)) {\n    return chunkStream(source);\n  }\n  if (isReadableStreamFallback(source)) {\n    return chunkStream(readStream(source));\n  }\n  throw new TypeError(\n    \"Unsupported data source: Expected either ReadableStream or async iterable.\"\n  );\n};\n\n// src/util/isFile.ts\nvar isFile = (value) => Boolean(\n  value && typeof value === \"object\" && isFunction(value.constructor) && value[Symbol.toStringTag] === \"File\" && isFunction(value.stream) && value.name != null\n);\n\n// src/util/isFormData.ts\nvar isFormData = (value) => Boolean(\n  value && isFunction(value.constructor) && value[Symbol.toStringTag] === \"FormData\" && isFunction(value.append) && isFunction(value.getAll) && isFunction(value.entries) && isFunction(value[Symbol.iterator])\n);\n\n// src/util/isPlainObject.ts\nvar getType = (value) => Object.prototype.toString.call(value).slice(8, -1).toLowerCase();\nfunction isPlainObject(value) {\n  if (getType(value) !== \"object\") {\n    return false;\n  }\n  const pp = Object.getPrototypeOf(value);\n  if (pp === null || pp === void 0) {\n    return true;\n  }\n  return pp.constructor?.toString?.() === Object.toString();\n}\n\n// src/util/normalizeValue.ts\nvar normalizeValue = (value) => String(value).replace(/\\r|\\n/g, (match, i, str) => {\n  if (match === \"\\r\" && str[i + 1] !== \"\\n\" || match === \"\\n\" && str[i - 1] !== \"\\r\") {\n    return \"\\r\\n\";\n  }\n  return match;\n});\n\n// src/util/proxyHeaders.ts\nfunction getProperty(target, prop) {\n  if (typeof prop === \"string\") {\n    for (const [name, value] of Object.entries(target)) {\n      if (prop.toLowerCase() === name.toLowerCase()) {\n        return value;\n      }\n    }\n  }\n  return void 0;\n}\nvar proxyHeaders = (object) => new Proxy(\n  object,\n  {\n    get: (target, prop) => getProperty(target, prop),\n    has: (target, prop) => getProperty(target, prop) !== void 0\n  }\n);\n\n// src/FormDataEncoder.ts\nvar defaultOptions = {\n  enableAdditionalHeaders: false\n};\nvar readonlyProp = { writable: false, configurable: false };\nvar _CRLF, _CRLF_BYTES, _CRLF_BYTES_LENGTH, _DASHES, _encoder, _footer, _form, _options, _FormDataEncoder_instances, getFieldHeader_fn, getContentLength_fn;\nvar FormDataEncoder = class {\n  constructor(form, boundaryOrOptions, options) {\n    __privateAdd(this, _FormDataEncoder_instances);\n    __privateAdd(this, _CRLF, \"\\r\\n\");\n    __privateAdd(this, _CRLF_BYTES);\n    __privateAdd(this, _CRLF_BYTES_LENGTH);\n    __privateAdd(this, _DASHES, \"-\".repeat(2));\n    /**\n     * TextEncoder instance\n     */\n    __privateAdd(this, _encoder, new TextEncoder());\n    /**\n     * Returns form-data footer bytes\n     */\n    __privateAdd(this, _footer);\n    /**\n     * FormData instance\n     */\n    __privateAdd(this, _form);\n    /**\n     * Instance options\n     */\n    __privateAdd(this, _options);\n    if (!isFormData(form)) {\n      throw new TypeError(\"Expected first argument to be a FormData instance.\");\n    }\n    let boundary;\n    if (isPlainObject(boundaryOrOptions)) {\n      options = boundaryOrOptions;\n    } else {\n      boundary = boundaryOrOptions;\n    }\n    if (!boundary) {\n      boundary = `form-data-encoder-${createBoundary()}`;\n    }\n    if (typeof boundary !== \"string\") {\n      throw new TypeError(\"Expected boundary argument to be a string.\");\n    }\n    if (options && !isPlainObject(options)) {\n      throw new TypeError(\"Expected options argument to be an object.\");\n    }\n    __privateSet(this, _form, Array.from(form.entries()));\n    __privateSet(this, _options, { ...defaultOptions, ...options });\n    __privateSet(this, _CRLF_BYTES, __privateGet(this, _encoder).encode(__privateGet(this, _CRLF)));\n    __privateSet(this, _CRLF_BYTES_LENGTH, __privateGet(this, _CRLF_BYTES).byteLength);\n    this.boundary = boundary;\n    this.contentType = `multipart/form-data; boundary=${this.boundary}`;\n    __privateSet(this, _footer, __privateGet(this, _encoder).encode(\n      `${__privateGet(this, _DASHES)}${this.boundary}${__privateGet(this, _DASHES)}${__privateGet(this, _CRLF).repeat(2)}`\n    ));\n    const headers = {\n      \"Content-Type\": this.contentType\n    };\n    const contentLength = __privateMethod(this, _FormDataEncoder_instances, getContentLength_fn).call(this);\n    if (contentLength) {\n      this.contentLength = contentLength;\n      headers[\"Content-Length\"] = contentLength;\n    }\n    this.headers = proxyHeaders(Object.freeze(headers));\n    Object.defineProperties(this, {\n      boundary: readonlyProp,\n      contentType: readonlyProp,\n      contentLength: readonlyProp,\n      headers: readonlyProp\n    });\n  }\n  /**\n   * Creates an iterator allowing to go through form-data parts (with metadata).\n   * This method **will not** read the files and **will not** split values big into smaller chunks.\n   *\n   * Using this method, you can convert form-data content into Blob:\n   *\n   * @example\n   *\n   * ```ts\n   * import {Readable} from \"stream\"\n   *\n   * import {FormDataEncoder} from \"form-data-encoder\"\n   *\n   * import {FormData} from \"formdata-polyfill/esm-min.js\"\n   * import {fileFrom} from \"fetch-blob/form.js\"\n   * import {File} from \"fetch-blob/file.js\"\n   * import {Blob} from \"fetch-blob\"\n   *\n   * import fetch from \"node-fetch\"\n   *\n   * const form = new FormData()\n   *\n   * form.set(\"field\", \"Just a random string\")\n   * form.set(\"file\", new File([\"Using files is class amazing\"]))\n   * form.set(\"fileFromPath\", await fileFrom(\"path/to/a/file.txt\"))\n   *\n   * const encoder = new FormDataEncoder(form)\n   *\n   * const options = {\n   *   method: \"post\",\n   *   body: new Blob(encoder, {type: encoder.contentType})\n   * }\n   *\n   * const response = await fetch(\"https://httpbin.org/post\", options)\n   *\n   * console.log(await response.json())\n   * ```\n   */\n  *values() {\n    for (const [name, raw] of __privateGet(this, _form)) {\n      const value = isFile(raw) ? raw : __privateGet(this, _encoder).encode(normalizeValue(raw));\n      yield __privateMethod(this, _FormDataEncoder_instances, getFieldHeader_fn).call(this, name, value);\n      yield value;\n      yield __privateGet(this, _CRLF_BYTES);\n    }\n    yield __privateGet(this, _footer);\n  }\n  /**\n   * Creates an async iterator allowing to perform the encoding by portions.\n   * This method reads through files and splits big values into smaller pieces (65536 bytes per each).\n   *\n   * @example\n   *\n   * ```ts\n   * import {Readable} from \"stream\"\n   *\n   * import {FormData, File, fileFromPath} from \"formdata-node\"\n   * import {FormDataEncoder} from \"form-data-encoder\"\n   *\n   * import fetch from \"node-fetch\"\n   *\n   * const form = new FormData()\n   *\n   * form.set(\"field\", \"Just a random string\")\n   * form.set(\"file\", new File([\"Using files is class amazing\"], \"file.txt\"))\n   * form.set(\"fileFromPath\", await fileFromPath(\"path/to/a/file.txt\"))\n   *\n   * const encoder = new FormDataEncoder(form)\n   *\n   * const options = {\n   *   method: \"post\",\n   *   headers: encoder.headers,\n   *   body: Readable.from(encoder.encode()) // or Readable.from(encoder)\n   * }\n   *\n   * const response = await fetch(\"https://httpbin.org/post\", options)\n   *\n   * console.log(await response.json())\n   * ```\n   */\n  async *encode() {\n    for (const part of this.values()) {\n      if (isFile(part)) {\n        yield* getStreamIterator(part.stream());\n      } else {\n        yield* chunk(part);\n      }\n    }\n  }\n  /**\n   * Creates an iterator allowing to read through the encoder data using for...of loops\n   */\n  [Symbol.iterator]() {\n    return this.values();\n  }\n  /**\n   * Creates an **async** iterator allowing to read through the encoder data using for-await...of loops\n   */\n  [Symbol.asyncIterator]() {\n    return this.encode();\n  }\n};\n_CRLF = new WeakMap();\n_CRLF_BYTES = new WeakMap();\n_CRLF_BYTES_LENGTH = new WeakMap();\n_DASHES = new WeakMap();\n_encoder = new WeakMap();\n_footer = new WeakMap();\n_form = new WeakMap();\n_options = new WeakMap();\n_FormDataEncoder_instances = new WeakSet();\ngetFieldHeader_fn = function(name, value) {\n  let header = \"\";\n  header += `${__privateGet(this, _DASHES)}${this.boundary}${__privateGet(this, _CRLF)}`;\n  header += `Content-Disposition: form-data; name=\"${escapeName(name)}\"`;\n  if (isFile(value)) {\n    header += `; filename=\"${escapeName(value.name)}\"${__privateGet(this, _CRLF)}`;\n    header += `Content-Type: ${value.type || \"application/octet-stream\"}`;\n  }\n  if (__privateGet(this, _options).enableAdditionalHeaders === true) {\n    const size = isFile(value) ? value.size : value.byteLength;\n    if (size != null && !isNaN(size)) {\n      header += `${__privateGet(this, _CRLF)}Content-Length: ${size}`;\n    }\n  }\n  return __privateGet(this, _encoder).encode(`${header}${__privateGet(this, _CRLF).repeat(2)}`);\n};\n/**\n * Returns form-data content length\n */\ngetContentLength_fn = function() {\n  let length = 0;\n  for (const [name, raw] of __privateGet(this, _form)) {\n    const value = isFile(raw) ? raw : __privateGet(this, _encoder).encode(normalizeValue(raw));\n    const size = isFile(value) ? value.size : value.byteLength;\n    if (size == null || isNaN(size)) {\n      return void 0;\n    }\n    length += __privateMethod(this, _FormDataEncoder_instances, getFieldHeader_fn).call(this, name, value).byteLength;\n    length += size;\n    length += __privateGet(this, _CRLF_BYTES_LENGTH);\n  }\n  return String(length + __privateGet(this, _footer).byteLength);\n};\nexport {\n  FormDataEncoder,\n  isFile,\n  isFormData\n};\n"],"mappings":";;;;;AAAA,IAAIA,WAAW,GAAIC,GAAG,IAAK;EACzB,MAAMC,SAAS,CAACD,GAAG,CAAC;AACtB,CAAC;AACD,IAAIE,aAAa,GAAGA,CAACC,GAAG,EAAEC,MAAM,EAAEJ,GAAG,KAAKI,MAAM,CAACC,GAAG,CAACF,GAAG,CAAC,IAAIJ,WAAW,CAAC,SAAS,GAAGC,GAAG,CAAC;AACzF,IAAIM,YAAY,GAAGA,CAACH,GAAG,EAAEC,MAAM,EAAEG,MAAM,MAAML,aAAa,CAACC,GAAG,EAAEC,MAAM,EAAE,yBAAyB,CAAC,EAAEG,MAAM,GAAGA,MAAM,CAACC,IAAI,CAACL,GAAG,CAAC,GAAGC,MAAM,CAACK,GAAG,CAACN,GAAG,CAAC,CAAC;AAChJ,IAAIO,YAAY,GAAGA,CAACP,GAAG,EAAEC,MAAM,EAAEO,KAAK,KAAKP,MAAM,CAACC,GAAG,CAACF,GAAG,CAAC,GAAGJ,WAAW,CAAC,mDAAmD,CAAC,GAAGK,MAAM,YAAYQ,OAAO,GAAGR,MAAM,CAACS,GAAG,CAACV,GAAG,CAAC,GAAGC,MAAM,CAACU,GAAG,CAACX,GAAG,EAAEQ,KAAK,CAAC;AACpM,IAAII,YAAY,GAAGA,CAACZ,GAAG,EAAEC,MAAM,EAAEO,KAAK,EAAEK,MAAM,MAAMd,aAAa,CAACC,GAAG,EAAEC,MAAM,EAAE,wBAAwB,CAAC,EAAEY,MAAM,GAAGA,MAAM,CAACR,IAAI,CAACL,GAAG,EAAEQ,KAAK,CAAC,GAAGP,MAAM,CAACU,GAAG,CAACX,GAAG,EAAEQ,KAAK,CAAC,EAAEA,KAAK,CAAC;AAC3K,IAAIM,eAAe,GAAGA,CAACd,GAAG,EAAEC,MAAM,EAAEc,MAAM,MAAMhB,aAAa,CAACC,GAAG,EAAEC,MAAM,EAAE,uBAAuB,CAAC,EAAEc,MAAM,CAAC;;AAE5G;AACA,IAAIC,cAAc,GAAG,KAAK;AAC1B,UAAUC,KAAKA,CAACT,KAAK,EAAE;EACrB,IAAIA,KAAK,CAACU,UAAU,IAAIF,cAAc,EAAE;IACtC,MAAMR,KAAK;IACX;EACF;EACA,IAAIW,MAAM,GAAG,CAAC;EACd,OAAOA,MAAM,GAAGX,KAAK,CAACU,UAAU,EAAE;IAChC,MAAME,IAAI,GAAGC,IAAI,CAACC,GAAG,CAACd,KAAK,CAACU,UAAU,GAAGC,MAAM,EAAEH,cAAc,CAAC;IAChE,MAAMO,MAAM,GAAGf,KAAK,CAACe,MAAM,CAACC,KAAK,CAACL,MAAM,EAAEA,MAAM,GAAGC,IAAI,CAAC;IACxDD,MAAM,IAAII,MAAM,CAACL,UAAU;IAC3B,MAAM,IAAIO,UAAU,CAACF,MAAM,CAAC;EAC9B;AACF;;AAEA;AACA,IAAIG,QAAQ,GAAG,sCAAsC;AACrD,SAASC,cAAcA,CAAA,EAAG;EACxB,IAAIP,IAAI,GAAG,EAAE;EACb,IAAIQ,GAAG,GAAG,EAAE;EACZ,OAAOR,IAAI,EAAE,EAAE;IACbQ,GAAG,IAAIF,QAAQ,CAACL,IAAI,CAACQ,MAAM,CAAC,CAAC,GAAGH,QAAQ,CAACI,MAAM,IAAI,CAAC,CAAC;EACvD;EACA,OAAOF,GAAG;AACZ;;AAEA;AACA,IAAIG,UAAU,GAAIC,IAAI,IAAKC,MAAM,CAACD,IAAI,CAAC,CAACE,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC,CAACA,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC,CAACA,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC;;AAExG;AACA,IAAIC,UAAU,GAAI3B,KAAK,IAAK,OAAOA,KAAK,KAAK,UAAU;;AAEvD;AACA,IAAI4B,wBAAwB,GAAI5B,KAAK,IAAK,CAAC,CAACA,KAAK,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAI,CAAC6B,KAAK,CAACC,OAAO,CAAC9B,KAAK,CAAC,IAAI2B,UAAU,CAAC3B,KAAK,CAAC+B,SAAS,CAAC;;AAEtI;AACA,IAAIC,eAAe,GAAIhC,KAAK,IAAK2B,UAAU,CAAC3B,KAAK,CAACiC,MAAM,CAACC,aAAa,CAAC,CAAC;;AAExE;AAAA,SACgBC,UAAUA,CAAAC,EAAA;EAAA,OAAAC,WAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAF,YAAA;EAAAA,WAAA,GAAAG,mBAAA,CAA1B,WAA2BC,QAAQ,EAAE;IACnC,MAAMC,MAAM,GAAGD,QAAQ,CAACV,SAAS,CAAC,CAAC;IACnC,OAAO,IAAI,EAAE;MACX,MAAM;QAAEY,IAAI;QAAE3C;MAAM,CAAC,SAAA4C,oBAAA,CAASF,MAAM,CAACG,IAAI,CAAC,CAAC;MAC3C,IAAIF,IAAI,EAAE;QACR;MACF;MACA,MAAM3C,KAAK;IACb;EACF,CAAC;EAAA,OAAAqC,WAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAAA,SACeO,WAAWA,CAAAC,GAAA;EAAA,OAAAC,YAAA,CAAAV,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAS,aAAA;EAAAA,YAAA,GAAAR,mBAAA,CAA3B,WAA4BS,MAAM,EAAE;IAAA,IAAAC,yBAAA;IAAA,IAAAC,iBAAA;IAAA,IAAAC,cAAA;IAAA;MAClC,SAAAC,SAAA,GAAAC,cAAA,CAA0BL,MAAM,GAAAM,KAAA,EAAAL,yBAAA,KAAAK,KAAA,SAAAX,oBAAA,CAAAS,SAAA,CAAAG,IAAA,KAAAb,IAAA,EAAAO,yBAAA,UAAE;QAAA,MAAjBlD,KAAK,GAAAuD,KAAA,CAAAvD,KAAA;QAAA;UACpB,OAAAyD,uBAAA,CAAAH,cAAA,CAAO7C,KAAK,CAACT,KAAK,CAAC,GAAA4C,oBAAA;QAAC;MACtB;IAAC,SAAAc,GAAA;MAAAP,iBAAA;MAAAC,cAAA,GAAAM,GAAA;IAAA;MAAA;QAAA,IAAAR,yBAAA,IAAAG,SAAA,CAAAM,MAAA;UAAA,MAAAf,oBAAA,CAAAS,SAAA,CAAAM,MAAA;QAAA;MAAA;QAAA,IAAAR,iBAAA;UAAA,MAAAC,cAAA;QAAA;MAAA;IAAA;EACH,CAAC;EAAA,OAAAJ,YAAA,CAAAV,KAAA,OAAAC,SAAA;AAAA;AACD,IAAIqB,iBAAiB,GAAIC,MAAM,IAAK;EAClC,IAAI7B,eAAe,CAAC6B,MAAM,CAAC,EAAE;IAC3B,OAAOf,WAAW,CAACe,MAAM,CAAC;EAC5B;EACA,IAAIjC,wBAAwB,CAACiC,MAAM,CAAC,EAAE;IACpC,OAAOf,WAAW,CAACX,UAAU,CAAC0B,MAAM,CAAC,CAAC;EACxC;EACA,MAAM,IAAIvE,SAAS,CACjB,4EACF,CAAC;AACH,CAAC;;AAED;AACA,IAAIwE,MAAM,GAAI9D,KAAK,IAAK+D,OAAO,CAC7B/D,KAAK,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAI2B,UAAU,CAAC3B,KAAK,CAACgE,WAAW,CAAC,IAAIhE,KAAK,CAACiC,MAAM,CAACgC,WAAW,CAAC,KAAK,MAAM,IAAItC,UAAU,CAAC3B,KAAK,CAACiD,MAAM,CAAC,IAAIjD,KAAK,CAACwB,IAAI,IAAI,IAC3J,CAAC;;AAED;AACA,IAAI0C,UAAU,GAAIlE,KAAK,IAAK+D,OAAO,CACjC/D,KAAK,IAAI2B,UAAU,CAAC3B,KAAK,CAACgE,WAAW,CAAC,IAAIhE,KAAK,CAACiC,MAAM,CAACgC,WAAW,CAAC,KAAK,UAAU,IAAItC,UAAU,CAAC3B,KAAK,CAACmE,MAAM,CAAC,IAAIxC,UAAU,CAAC3B,KAAK,CAACoE,MAAM,CAAC,IAAIzC,UAAU,CAAC3B,KAAK,CAACqE,OAAO,CAAC,IAAI1C,UAAU,CAAC3B,KAAK,CAACiC,MAAM,CAACqC,QAAQ,CAAC,CAC9M,CAAC;;AAED;AACA,IAAIC,OAAO,GAAIvE,KAAK,IAAKwE,MAAM,CAACC,SAAS,CAACC,QAAQ,CAAC7E,IAAI,CAACG,KAAK,CAAC,CAACgB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC2D,WAAW,CAAC,CAAC;AACzF,SAASC,aAAaA,CAAC5E,KAAK,EAAE;EAAA,IAAA6E,eAAA,EAAAC,qBAAA;EAC5B,IAAIP,OAAO,CAACvE,KAAK,CAAC,KAAK,QAAQ,EAAE;IAC/B,OAAO,KAAK;EACd;EACA,MAAM+E,EAAE,GAAGP,MAAM,CAACQ,cAAc,CAAChF,KAAK,CAAC;EACvC,IAAI+E,EAAE,KAAK,IAAI,IAAIA,EAAE,KAAK,KAAK,CAAC,EAAE;IAChC,OAAO,IAAI;EACb;EACA,OAAO,EAAAF,eAAA,GAAAE,EAAE,CAACf,WAAW,cAAAa,eAAA,gBAAAC,qBAAA,GAAdD,eAAA,CAAgBH,QAAQ,cAAAI,qBAAA,uBAAxBA,qBAAA,CAAAjF,IAAA,CAAAgF,eAA2B,CAAC,MAAKL,MAAM,CAACE,QAAQ,CAAC,CAAC;AAC3D;;AAEA;AACA,IAAIO,cAAc,GAAIjF,KAAK,IAAKyB,MAAM,CAACzB,KAAK,CAAC,CAAC0B,OAAO,CAAC,QAAQ,EAAE,CAACwD,KAAK,EAAEC,CAAC,EAAEC,GAAG,KAAK;EACjF,IAAIF,KAAK,KAAK,IAAI,IAAIE,GAAG,CAACD,CAAC,GAAG,CAAC,CAAC,KAAK,IAAI,IAAID,KAAK,KAAK,IAAI,IAAIE,GAAG,CAACD,CAAC,GAAG,CAAC,CAAC,KAAK,IAAI,EAAE;IAClF,OAAO,MAAM;EACf;EACA,OAAOD,KAAK;AACd,CAAC,CAAC;;AAEF;AACA,SAASG,WAAWA,CAACC,MAAM,EAAEC,IAAI,EAAE;EACjC,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;IAC5B,KAAK,MAAM,CAAC/D,IAAI,EAAExB,KAAK,CAAC,IAAIwE,MAAM,CAACH,OAAO,CAACiB,MAAM,CAAC,EAAE;MAClD,IAAIC,IAAI,CAACZ,WAAW,CAAC,CAAC,KAAKnD,IAAI,CAACmD,WAAW,CAAC,CAAC,EAAE;QAC7C,OAAO3E,KAAK;MACd;IACF;EACF;EACA,OAAO,KAAK,CAAC;AACf;AACA,IAAIwF,YAAY,GAAIC,MAAM,IAAK,IAAIC,KAAK,CACtCD,MAAM,EACN;EACE3F,GAAG,EAAEA,CAACwF,MAAM,EAAEC,IAAI,KAAKF,WAAW,CAACC,MAAM,EAAEC,IAAI,CAAC;EAChD7F,GAAG,EAAEA,CAAC4F,MAAM,EAAEC,IAAI,KAAKF,WAAW,CAACC,MAAM,EAAEC,IAAI,CAAC,KAAK,KAAK;AAC5D,CACF,CAAC;;AAED;AACA,IAAII,cAAc,GAAG;EACnBC,uBAAuB,EAAE;AAC3B,CAAC;AACD,IAAIC,YAAY,GAAG;EAAEC,QAAQ,EAAE,KAAK;EAAEC,YAAY,EAAE;AAAM,CAAC;AAC3D,IAAIC,KAAK,EAAEC,WAAW,EAAEC,kBAAkB,EAAEC,OAAO,EAAEC,QAAQ,EAAEC,OAAO,EAAEC,KAAK,EAAEC,QAAQ,EAAEC,0BAA0B,EAAEC,iBAAiB,EAAEC,mBAAmB;AAC3J,IAAIC,eAAe,GAAG,MAAM;EAC1B3C,WAAWA,CAAC4C,IAAI,EAAEC,iBAAiB,EAAEC,OAAO,EAAE;IAC5C/G,YAAY,CAAC,IAAI,EAAEyG,0BAA0B,CAAC;IAC9CzG,YAAY,CAAC,IAAI,EAAEiG,KAAK,EAAE,MAAM,CAAC;IACjCjG,YAAY,CAAC,IAAI,EAAEkG,WAAW,CAAC;IAC/BlG,YAAY,CAAC,IAAI,EAAEmG,kBAAkB,CAAC;IACtCnG,YAAY,CAAC,IAAI,EAAEoG,OAAO,EAAE,GAAG,CAACY,MAAM,CAAC,CAAC,CAAC,CAAC;IAC1C;AACJ;AACA;IACIhH,YAAY,CAAC,IAAI,EAAEqG,QAAQ,EAAE,IAAIY,WAAW,CAAC,CAAC,CAAC;IAC/C;AACJ;AACA;IACIjH,YAAY,CAAC,IAAI,EAAEsG,OAAO,CAAC;IAC3B;AACJ;AACA;IACItG,YAAY,CAAC,IAAI,EAAEuG,KAAK,CAAC;IACzB;AACJ;AACA;IACIvG,YAAY,CAAC,IAAI,EAAEwG,QAAQ,CAAC;IAC5B,IAAI,CAACrC,UAAU,CAAC0C,IAAI,CAAC,EAAE;MACrB,MAAM,IAAItH,SAAS,CAAC,oDAAoD,CAAC;IAC3E;IACA,IAAI2H,QAAQ;IACZ,IAAIrC,aAAa,CAACiC,iBAAiB,CAAC,EAAE;MACpCC,OAAO,GAAGD,iBAAiB;IAC7B,CAAC,MAAM;MACLI,QAAQ,GAAGJ,iBAAiB;IAC9B;IACA,IAAI,CAACI,QAAQ,EAAE;MACbA,QAAQ,wBAAAC,MAAA,CAAwB/F,cAAc,CAAC,CAAC,CAAE;IACpD;IACA,IAAI,OAAO8F,QAAQ,KAAK,QAAQ,EAAE;MAChC,MAAM,IAAI3H,SAAS,CAAC,4CAA4C,CAAC;IACnE;IACA,IAAIwH,OAAO,IAAI,CAAClC,aAAa,CAACkC,OAAO,CAAC,EAAE;MACtC,MAAM,IAAIxH,SAAS,CAAC,4CAA4C,CAAC;IACnE;IACAc,YAAY,CAAC,IAAI,EAAEkG,KAAK,EAAEzE,KAAK,CAACsF,IAAI,CAACP,IAAI,CAACvC,OAAO,CAAC,CAAC,CAAC,CAAC;IACrDjE,YAAY,CAAC,IAAI,EAAEmG,QAAQ,EAAAa,aAAA,CAAAA,aAAA,KAAOzB,cAAc,GAAKmB,OAAO,CAAE,CAAC;IAC/D1G,YAAY,CAAC,IAAI,EAAE6F,WAAW,EAAEtG,YAAY,CAAC,IAAI,EAAEyG,QAAQ,CAAC,CAACiB,MAAM,CAAC1H,YAAY,CAAC,IAAI,EAAEqG,KAAK,CAAC,CAAC,CAAC;IAC/F5F,YAAY,CAAC,IAAI,EAAE8F,kBAAkB,EAAEvG,YAAY,CAAC,IAAI,EAAEsG,WAAW,CAAC,CAACvF,UAAU,CAAC;IAClF,IAAI,CAACuG,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACK,WAAW,oCAAAJ,MAAA,CAAoC,IAAI,CAACD,QAAQ,CAAE;IACnE7G,YAAY,CAAC,IAAI,EAAEiG,OAAO,EAAE1G,YAAY,CAAC,IAAI,EAAEyG,QAAQ,CAAC,CAACiB,MAAM,IAAAH,MAAA,CAC1DvH,YAAY,CAAC,IAAI,EAAEwG,OAAO,CAAC,EAAAe,MAAA,CAAG,IAAI,CAACD,QAAQ,EAAAC,MAAA,CAAGvH,YAAY,CAAC,IAAI,EAAEwG,OAAO,CAAC,EAAAe,MAAA,CAAGvH,YAAY,CAAC,IAAI,EAAEqG,KAAK,CAAC,CAACe,MAAM,CAAC,CAAC,CAAC,CACpH,CAAC,CAAC;IACF,MAAMQ,OAAO,GAAG;MACd,cAAc,EAAE,IAAI,CAACD;IACvB,CAAC;IACD,MAAME,aAAa,GAAGlH,eAAe,CAAC,IAAI,EAAEkG,0BAA0B,EAAEE,mBAAmB,CAAC,CAAC7G,IAAI,CAAC,IAAI,CAAC;IACvG,IAAI2H,aAAa,EAAE;MACjB,IAAI,CAACA,aAAa,GAAGA,aAAa;MAClCD,OAAO,CAAC,gBAAgB,CAAC,GAAGC,aAAa;IAC3C;IACA,IAAI,CAACD,OAAO,GAAG/B,YAAY,CAAChB,MAAM,CAACiD,MAAM,CAACF,OAAO,CAAC,CAAC;IACnD/C,MAAM,CAACkD,gBAAgB,CAAC,IAAI,EAAE;MAC5BT,QAAQ,EAAEpB,YAAY;MACtByB,WAAW,EAAEzB,YAAY;MACzB2B,aAAa,EAAE3B,YAAY;MAC3B0B,OAAO,EAAE1B;IACX,CAAC,CAAC;EACJ;EACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,CAAC8B,MAAMA,CAAA,EAAG;IACR,KAAK,MAAM,CAACnG,IAAI,EAAEoG,GAAG,CAAC,IAAIjI,YAAY,CAAC,IAAI,EAAE2G,KAAK,CAAC,EAAE;MACnD,MAAMtG,KAAK,GAAG8D,MAAM,CAAC8D,GAAG,CAAC,GAAGA,GAAG,GAAGjI,YAAY,CAAC,IAAI,EAAEyG,QAAQ,CAAC,CAACiB,MAAM,CAACpC,cAAc,CAAC2C,GAAG,CAAC,CAAC;MAC1F,MAAMtH,eAAe,CAAC,IAAI,EAAEkG,0BAA0B,EAAEC,iBAAiB,CAAC,CAAC5G,IAAI,CAAC,IAAI,EAAE2B,IAAI,EAAExB,KAAK,CAAC;MAClG,MAAMA,KAAK;MACX,MAAML,YAAY,CAAC,IAAI,EAAEsG,WAAW,CAAC;IACvC;IACA,MAAMtG,YAAY,CAAC,IAAI,EAAE0G,OAAO,CAAC;EACnC;EACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACSgB,MAAMA,CAAA,EAAG;IAAA,IAAAQ,KAAA;IAAA,OAAArF,mBAAA;MACd,KAAK,MAAMsF,IAAI,IAAID,KAAI,CAACF,MAAM,CAAC,CAAC,EAAE;QAChC,IAAI7D,MAAM,CAACgE,IAAI,CAAC,EAAE;UAChB,OAAArE,uBAAA,CAAAH,cAAA,CAAOM,iBAAiB,CAACkE,IAAI,CAAC7E,MAAM,CAAC,CAAC,CAAC,GAAAL,oBAAA;QACzC,CAAC,MAAM;UACL,OAAAa,uBAAA,CAAAH,cAAA,CAAO7C,KAAK,CAACqH,IAAI,CAAC,GAAAlF,oBAAA;QACpB;MACF;IAAC;EACH;EACA;AACF;AACA;EACE,CAACX,MAAM,CAACqC,QAAQ,IAAI;IAClB,OAAO,IAAI,CAACqD,MAAM,CAAC,CAAC;EACtB;EACA;AACF;AACA;EACE,CAAC1F,MAAM,CAACC,aAAa,IAAI;IACvB,OAAO,IAAI,CAACmF,MAAM,CAAC,CAAC;EACtB;AACF,CAAC;AACDrB,KAAK,GAAG,IAAI+B,OAAO,CAAC,CAAC;AACrB9B,WAAW,GAAG,IAAI8B,OAAO,CAAC,CAAC;AAC3B7B,kBAAkB,GAAG,IAAI6B,OAAO,CAAC,CAAC;AAClC5B,OAAO,GAAG,IAAI4B,OAAO,CAAC,CAAC;AACvB3B,QAAQ,GAAG,IAAI2B,OAAO,CAAC,CAAC;AACxB1B,OAAO,GAAG,IAAI0B,OAAO,CAAC,CAAC;AACvBzB,KAAK,GAAG,IAAIyB,OAAO,CAAC,CAAC;AACrBxB,QAAQ,GAAG,IAAIwB,OAAO,CAAC,CAAC;AACxBvB,0BAA0B,GAAG,IAAIvG,OAAO,CAAC,CAAC;AAC1CwG,iBAAiB,GAAG,SAAAA,CAASjF,IAAI,EAAExB,KAAK,EAAE;EACxC,IAAIgI,MAAM,GAAG,EAAE;EACfA,MAAM,OAAAd,MAAA,CAAOvH,YAAY,CAAC,IAAI,EAAEwG,OAAO,CAAC,EAAAe,MAAA,CAAG,IAAI,CAACD,QAAQ,EAAAC,MAAA,CAAGvH,YAAY,CAAC,IAAI,EAAEqG,KAAK,CAAC,CAAE;EACtFgC,MAAM,8CAAAd,MAAA,CAA6C3F,UAAU,CAACC,IAAI,CAAC,OAAG;EACtE,IAAIsC,MAAM,CAAC9D,KAAK,CAAC,EAAE;IACjBgI,MAAM,oBAAAd,MAAA,CAAmB3F,UAAU,CAACvB,KAAK,CAACwB,IAAI,CAAC,QAAA0F,MAAA,CAAIvH,YAAY,CAAC,IAAI,EAAEqG,KAAK,CAAC,CAAE;IAC9EgC,MAAM,qBAAAd,MAAA,CAAqBlH,KAAK,CAACiI,IAAI,IAAI,0BAA0B,CAAE;EACvE;EACA,IAAItI,YAAY,CAAC,IAAI,EAAE4G,QAAQ,CAAC,CAACX,uBAAuB,KAAK,IAAI,EAAE;IACjE,MAAMhF,IAAI,GAAGkD,MAAM,CAAC9D,KAAK,CAAC,GAAGA,KAAK,CAACY,IAAI,GAAGZ,KAAK,CAACU,UAAU;IAC1D,IAAIE,IAAI,IAAI,IAAI,IAAI,CAACsH,KAAK,CAACtH,IAAI,CAAC,EAAE;MAChCoH,MAAM,OAAAd,MAAA,CAAOvH,YAAY,CAAC,IAAI,EAAEqG,KAAK,CAAC,sBAAAkB,MAAA,CAAmBtG,IAAI,CAAE;IACjE;EACF;EACA,OAAOjB,YAAY,CAAC,IAAI,EAAEyG,QAAQ,CAAC,CAACiB,MAAM,IAAAH,MAAA,CAAIc,MAAM,EAAAd,MAAA,CAAGvH,YAAY,CAAC,IAAI,EAAEqG,KAAK,CAAC,CAACe,MAAM,CAAC,CAAC,CAAC,CAAE,CAAC;AAC/F,CAAC;AACD;AACA;AACA;AACAL,mBAAmB,GAAG,SAAAA,CAAA,EAAW;EAC/B,IAAIpF,MAAM,GAAG,CAAC;EACd,KAAK,MAAM,CAACE,IAAI,EAAEoG,GAAG,CAAC,IAAIjI,YAAY,CAAC,IAAI,EAAE2G,KAAK,CAAC,EAAE;IACnD,MAAMtG,KAAK,GAAG8D,MAAM,CAAC8D,GAAG,CAAC,GAAGA,GAAG,GAAGjI,YAAY,CAAC,IAAI,EAAEyG,QAAQ,CAAC,CAACiB,MAAM,CAACpC,cAAc,CAAC2C,GAAG,CAAC,CAAC;IAC1F,MAAMhH,IAAI,GAAGkD,MAAM,CAAC9D,KAAK,CAAC,GAAGA,KAAK,CAACY,IAAI,GAAGZ,KAAK,CAACU,UAAU;IAC1D,IAAIE,IAAI,IAAI,IAAI,IAAIsH,KAAK,CAACtH,IAAI,CAAC,EAAE;MAC/B,OAAO,KAAK,CAAC;IACf;IACAU,MAAM,IAAIhB,eAAe,CAAC,IAAI,EAAEkG,0BAA0B,EAAEC,iBAAiB,CAAC,CAAC5G,IAAI,CAAC,IAAI,EAAE2B,IAAI,EAAExB,KAAK,CAAC,CAACU,UAAU;IACjHY,MAAM,IAAIV,IAAI;IACdU,MAAM,IAAI3B,YAAY,CAAC,IAAI,EAAEuG,kBAAkB,CAAC;EAClD;EACA,OAAOzE,MAAM,CAACH,MAAM,GAAG3B,YAAY,CAAC,IAAI,EAAE0G,OAAO,CAAC,CAAC3F,UAAU,CAAC;AAChE,CAAC;AACD,SACEiG,eAAe,EACf7C,MAAM,EACNI,UAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}