{"ast":null,"code":"import _defineProperty from \"C:/Users/sakas/OneDrive/Desktop/gogo/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _asyncIterator from \"C:/Users/sakas/OneDrive/Desktop/gogo/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\nimport process from 'node:process';\nimport { Buffer } from 'node:buffer';\nimport { Duplex } from 'node:stream';\nimport http, { ServerResponse } from 'node:http';\nimport timer from '@szmarczak/http-timer';\nimport CacheableRequest, { CacheError as CacheableCacheError } from 'cacheable-request';\nimport decompressResponse from 'decompress-response';\nimport is, { isBuffer } from '@sindresorhus/is';\nimport { FormDataEncoder, isFormData as isFormDataLike } from 'form-data-encoder';\nimport getBodySize from './utils/get-body-size.js';\nimport isFormData from './utils/is-form-data.js';\nimport proxyEvents from './utils/proxy-events.js';\nimport timedOut, { TimeoutError as TimedOutTimeoutError } from './timed-out.js';\nimport urlToOptions from './utils/url-to-options.js';\nimport WeakableMap from './utils/weakable-map.js';\nimport calculateRetryDelay from './calculate-retry-delay.js';\nimport Options from './options.js';\nimport { isResponseOk } from './response.js';\nimport isClientRequest from './utils/is-client-request.js';\nimport isUnixSocketURL from './utils/is-unix-socket-url.js';\nimport { RequestError, ReadError, MaxRedirectsError, HTTPError, TimeoutError, UploadError, CacheError, AbortError } from './errors.js';\nconst supportsBrotli = is.string(process.versions.brotli);\nconst methodsWithoutBody = new Set(['GET', 'HEAD']);\nconst cacheableStore = new WeakableMap();\nconst redirectCodes = new Set([300, 301, 302, 303, 304, 307, 308]);\nconst proxiedRequestEvents = ['socket', 'connect', 'continue', 'information', 'upgrade'];\nconst noop = () => {};\nexport default class Request extends Duplex {\n  constructor(url, options, defaults) {\n    super({\n      // Don't destroy immediately, as the error may be emitted on unsuccessful retry\n      autoDestroy: false,\n      // It needs to be zero because we're just proxying the data to another stream\n      highWaterMark: 0\n    });\n    // @ts-expect-error - Ignoring for now.\n    _defineProperty(this, 'constructor', void 0);\n    _defineProperty(this, \"_noPipe\", void 0);\n    // @ts-expect-error https://github.com/microsoft/TypeScript/issues/9568\n    _defineProperty(this, \"options\", void 0);\n    _defineProperty(this, \"response\", void 0);\n    _defineProperty(this, \"requestUrl\", void 0);\n    _defineProperty(this, \"redirectUrls\", void 0);\n    _defineProperty(this, \"retryCount\", void 0);\n    _defineProperty(this, \"_stopRetry\", void 0);\n    _defineProperty(this, \"_downloadedSize\", void 0);\n    _defineProperty(this, \"_uploadedSize\", void 0);\n    _defineProperty(this, \"_stopReading\", void 0);\n    _defineProperty(this, \"_pipedServerResponses\", void 0);\n    _defineProperty(this, \"_request\", void 0);\n    _defineProperty(this, \"_responseSize\", void 0);\n    _defineProperty(this, \"_bodySize\", void 0);\n    _defineProperty(this, \"_unproxyEvents\", void 0);\n    _defineProperty(this, \"_isFromCache\", void 0);\n    _defineProperty(this, \"_cannotHaveBody\", void 0);\n    _defineProperty(this, \"_triggerRead\", void 0);\n    _defineProperty(this, \"_cancelTimeouts\", void 0);\n    _defineProperty(this, \"_removeListeners\", void 0);\n    _defineProperty(this, \"_nativeResponse\", void 0);\n    _defineProperty(this, \"_flushed\", void 0);\n    _defineProperty(this, \"_aborted\", void 0);\n    // We need this because `this._request` if `undefined` when using cache\n    _defineProperty(this, \"_requestInitialized\", void 0);\n    this._downloadedSize = 0;\n    this._uploadedSize = 0;\n    this._stopReading = false;\n    this._pipedServerResponses = new Set();\n    this._cannotHaveBody = false;\n    this._unproxyEvents = noop;\n    this._triggerRead = false;\n    this._cancelTimeouts = noop;\n    this._removeListeners = noop;\n    this._jobs = [];\n    this._flushed = false;\n    this._requestInitialized = false;\n    this._aborted = false;\n    this.redirectUrls = [];\n    this.retryCount = 0;\n    this._stopRetry = noop;\n    this.on('pipe', source => {\n      if (source !== null && source !== void 0 && source.headers) {\n        Object.assign(this.options.headers, source.headers);\n      }\n    });\n    this.on('newListener', event => {\n      if (event === 'retry' && this.listenerCount('retry') > 0) {\n        throw new Error('A retry listener has been attached already.');\n      }\n    });\n    try {\n      this.options = new Options(url, options, defaults);\n      if (!this.options.url) {\n        if (this.options.prefixUrl === '') {\n          throw new TypeError('Missing `url` property');\n        }\n        this.options.url = '';\n      }\n      this.requestUrl = this.options.url;\n    } catch (error) {\n      const {\n        options\n      } = error;\n      if (options) {\n        this.options = options;\n      }\n      this.flush = async () => {\n        this.flush = async () => {};\n        this.destroy(error);\n      };\n      return;\n    }\n    // Important! If you replace `body` in a handler with another stream, make sure it's readable first.\n    // The below is run only once.\n    const {\n      body\n    } = this.options;\n    if (is.nodeStream(body)) {\n      body.once('error', error => {\n        if (this._flushed) {\n          this._beforeError(new UploadError(error, this));\n        } else {\n          this.flush = async () => {\n            this.flush = async () => {};\n            this._beforeError(new UploadError(error, this));\n          };\n        }\n      });\n    }\n    if (this.options.signal) {\n      const abort = () => {\n        var _this$options$signal;\n        // See https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/timeout_static#return_value\n        if (((_this$options$signal = this.options.signal) === null || _this$options$signal === void 0 || (_this$options$signal = _this$options$signal.reason) === null || _this$options$signal === void 0 ? void 0 : _this$options$signal.name) === 'TimeoutError') {\n          this.destroy(new TimeoutError(this.options.signal.reason, this.timings, this));\n        } else {\n          this.destroy(new AbortError(this));\n        }\n      };\n      if (this.options.signal.aborted) {\n        abort();\n      } else {\n        this.options.signal.addEventListener('abort', abort);\n        this._removeListeners = () => {\n          var _this$options$signal2;\n          (_this$options$signal2 = this.options.signal) === null || _this$options$signal2 === void 0 || _this$options$signal2.removeEventListener('abort', abort);\n        };\n      }\n    }\n  }\n  async flush() {\n    if (this._flushed) {\n      return;\n    }\n    this._flushed = true;\n    try {\n      await this._finalizeBody();\n      if (this.destroyed) {\n        return;\n      }\n      await this._makeRequest();\n      if (this.destroyed) {\n        var _this$_request;\n        (_this$_request = this._request) === null || _this$_request === void 0 || _this$_request.destroy();\n        return;\n      }\n      // Queued writes etc.\n      for (const job of this._jobs) {\n        job();\n      }\n      // Prevent memory leak\n      this._jobs.length = 0;\n      this._requestInitialized = true;\n    } catch (error) {\n      this._beforeError(error);\n    }\n  }\n  _beforeError(error) {\n    if (this._stopReading) {\n      return;\n    }\n    const {\n      response,\n      options\n    } = this;\n    const attemptCount = this.retryCount + (error.name === 'RetryError' ? 0 : 1);\n    this._stopReading = true;\n    if (!(error instanceof RequestError)) {\n      error = new RequestError(error.message, error, this);\n    }\n    const typedError = error;\n    void (async _this$_request2 => {\n      // Node.js parser is really weird.\n      // It emits post-request Parse Errors on the same instance as previous request. WTF.\n      // Therefore, we need to check if it has been destroyed as well.\n      //\n      // Furthermore, Node.js 16 `response.destroy()` doesn't immediately destroy the socket,\n      // but makes the response unreadable. So we additionally need to check `response.readable`.\n      if (response !== null && response !== void 0 && response.readable && !response.rawBody && !((_this$_request2 = this._request) !== null && _this$_request2 !== void 0 && (_this$_request2 = _this$_request2.socket) !== null && _this$_request2 !== void 0 && _this$_request2.destroyed)) {\n        // @types/node has incorrect typings. `setEncoding` accepts `null` as well.\n        response.setEncoding(this.readableEncoding);\n        const success = await this._setRawBody(response);\n        if (success) {\n          response.body = response.rawBody.toString();\n        }\n      }\n      if (this.listenerCount('retry') !== 0) {\n        let backoff;\n        try {\n          var _ref, _retryOptions$maxRetr;\n          let retryAfter;\n          if (response && 'retry-after' in response.headers) {\n            retryAfter = Number(response.headers['retry-after']);\n            if (Number.isNaN(retryAfter)) {\n              retryAfter = Date.parse(response.headers['retry-after']) - Date.now();\n              if (retryAfter <= 0) {\n                retryAfter = 1;\n              }\n            } else {\n              retryAfter *= 1000;\n            }\n          }\n          const retryOptions = options.retry;\n          backoff = await retryOptions.calculateDelay({\n            attemptCount,\n            retryOptions,\n            error: typedError,\n            retryAfter,\n            computedValue: calculateRetryDelay({\n              attemptCount,\n              retryOptions,\n              error: typedError,\n              retryAfter,\n              computedValue: (_ref = (_retryOptions$maxRetr = retryOptions.maxRetryAfter) !== null && _retryOptions$maxRetr !== void 0 ? _retryOptions$maxRetr : options.timeout.request) !== null && _ref !== void 0 ? _ref : Number.POSITIVE_INFINITY\n            })\n          });\n        } catch (error_) {\n          void this._error(new RequestError(error_.message, error_, this));\n          return;\n        }\n        if (backoff) {\n          await new Promise(resolve => {\n            const timeout = setTimeout(resolve, backoff);\n            this._stopRetry = () => {\n              clearTimeout(timeout);\n              resolve();\n            };\n          });\n          // Something forced us to abort the retry\n          if (this.destroyed) {\n            return;\n          }\n          try {\n            for (const hook of this.options.hooks.beforeRetry) {\n              // eslint-disable-next-line no-await-in-loop\n              await hook(typedError, this.retryCount + 1);\n            }\n          } catch (error_) {\n            void this._error(new RequestError(error_.message, error, this));\n            return;\n          }\n          // Something forced us to abort the retry\n          if (this.destroyed) {\n            return;\n          }\n          this.destroy();\n          this.emit('retry', this.retryCount + 1, error, updatedOptions => {\n            const request = new Request(options.url, updatedOptions, options);\n            request.retryCount = this.retryCount + 1;\n            process.nextTick(() => {\n              void request.flush();\n            });\n            return request;\n          });\n          return;\n        }\n      }\n      void this._error(typedError);\n    })();\n  }\n  _read() {\n    this._triggerRead = true;\n    const {\n      response\n    } = this;\n    if (response && !this._stopReading) {\n      // We cannot put this in the `if` above\n      // because `.read()` also triggers the `end` event\n      if (response.readableLength) {\n        this._triggerRead = false;\n      }\n      let data;\n      while ((data = response.read()) !== null) {\n        this._downloadedSize += data.length; // eslint-disable-line @typescript-eslint/restrict-plus-operands\n        const progress = this.downloadProgress;\n        if (progress.percent < 1) {\n          this.emit('downloadProgress', progress);\n        }\n        this.push(data);\n      }\n    }\n  }\n  _write(chunk, encoding, callback) {\n    const write = () => {\n      this._writeRequest(chunk, encoding, callback);\n    };\n    if (this._requestInitialized) {\n      write();\n    } else {\n      this._jobs.push(write);\n    }\n  }\n  _final(callback) {\n    const endRequest = () => {\n      // We need to check if `this._request` is present,\n      // because it isn't when we use cache.\n      if (!this._request || this._request.destroyed) {\n        callback();\n        return;\n      }\n      this._request.end(error => {\n        var _this$_request3;\n        // The request has been destroyed before `_final` finished.\n        // See https://github.com/nodejs/node/issues/39356\n        if ((_this$_request3 = this._request) !== null && _this$_request3 !== void 0 && (_this$_request3 = _this$_request3._writableState) !== null && _this$_request3 !== void 0 && _this$_request3.errored) {\n          return;\n        }\n        if (!error) {\n          var _this$_request4;\n          this._bodySize = this._uploadedSize;\n          this.emit('uploadProgress', this.uploadProgress);\n          (_this$_request4 = this._request) === null || _this$_request4 === void 0 || _this$_request4.emit('upload-complete');\n        }\n        callback(error);\n      });\n    };\n    if (this._requestInitialized) {\n      endRequest();\n    } else {\n      this._jobs.push(endRequest);\n    }\n  }\n  _destroy(error, callback) {\n    this._stopReading = true;\n    this.flush = async () => {};\n    // Prevent further retries\n    this._stopRetry();\n    this._cancelTimeouts();\n    this._removeListeners();\n    if (this.options) {\n      const {\n        body\n      } = this.options;\n      if (is.nodeStream(body)) {\n        body.destroy();\n      }\n    }\n    if (this._request) {\n      this._request.destroy();\n    }\n    if (error !== null && !is.undefined(error) && !(error instanceof RequestError)) {\n      error = new RequestError(error.message, error, this);\n    }\n    callback(error);\n  }\n  pipe(destination, options) {\n    if (destination instanceof ServerResponse) {\n      this._pipedServerResponses.add(destination);\n    }\n    return super.pipe(destination, options);\n  }\n  unpipe(destination) {\n    if (destination instanceof ServerResponse) {\n      this._pipedServerResponses.delete(destination);\n    }\n    super.unpipe(destination);\n    return this;\n  }\n  async _finalizeBody() {\n    const {\n      options\n    } = this;\n    const {\n      headers\n    } = options;\n    const isForm = !is.undefined(options.form);\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    const isJSON = !is.undefined(options.json);\n    const isBody = !is.undefined(options.body);\n    const cannotHaveBody = methodsWithoutBody.has(options.method) && !(options.method === 'GET' && options.allowGetBody);\n    this._cannotHaveBody = cannotHaveBody;\n    if (isForm || isJSON || isBody) {\n      if (cannotHaveBody) {\n        throw new TypeError(\"The `\".concat(options.method, \"` method cannot be used with a body\"));\n      }\n      // Serialize body\n      const noContentType = !is.string(headers['content-type']);\n      if (isBody) {\n        // Body is spec-compliant FormData\n        if (isFormDataLike(options.body)) {\n          const encoder = new FormDataEncoder(options.body);\n          if (noContentType) {\n            headers['content-type'] = encoder.headers['Content-Type'];\n          }\n          if ('Content-Length' in encoder.headers) {\n            headers['content-length'] = encoder.headers['Content-Length'];\n          }\n          options.body = encoder.encode();\n        }\n        // Special case for https://github.com/form-data/form-data\n        if (isFormData(options.body) && noContentType) {\n          headers['content-type'] = \"multipart/form-data; boundary=\".concat(options.body.getBoundary());\n        }\n      } else if (isForm) {\n        if (noContentType) {\n          headers['content-type'] = 'application/x-www-form-urlencoded';\n        }\n        const {\n          form\n        } = options;\n        options.form = undefined;\n        options.body = new URLSearchParams(form).toString();\n      } else {\n        if (noContentType) {\n          headers['content-type'] = 'application/json';\n        }\n        const {\n          json\n        } = options;\n        options.json = undefined;\n        options.body = options.stringifyJson(json);\n      }\n      const uploadBodySize = await getBodySize(options.body, options.headers);\n      // See https://tools.ietf.org/html/rfc7230#section-3.3.2\n      // A user agent SHOULD send a Content-Length in a request message when\n      // no Transfer-Encoding is sent and the request method defines a meaning\n      // for an enclosed payload body.  For example, a Content-Length header\n      // field is normally sent in a POST request even when the value is 0\n      // (indicating an empty payload body).  A user agent SHOULD NOT send a\n      // Content-Length header field when the request message does not contain\n      // a payload body and the method semantics do not anticipate such a\n      // body.\n      if (is.undefined(headers['content-length']) && is.undefined(headers['transfer-encoding']) && !cannotHaveBody && !is.undefined(uploadBodySize)) {\n        headers['content-length'] = String(uploadBodySize);\n      }\n    }\n    if (options.responseType === 'json' && !('accept' in options.headers)) {\n      options.headers.accept = 'application/json';\n    }\n    this._bodySize = Number(headers['content-length']) || undefined;\n  }\n  async _onResponseBase(response) {\n    var _typedResponse$status, _this$_nativeResponse;\n    // This will be called e.g. when using cache so we need to check if this request has been aborted.\n    if (this.isAborted) {\n      return;\n    }\n    const {\n      options\n    } = this;\n    const {\n      url\n    } = options;\n    this._nativeResponse = response;\n    if (options.decompress) {\n      response = decompressResponse(response);\n    }\n    const statusCode = response.statusCode;\n    const typedResponse = response;\n    typedResponse.statusMessage = (_typedResponse$status = typedResponse.statusMessage) !== null && _typedResponse$status !== void 0 ? _typedResponse$status : http.STATUS_CODES[statusCode];\n    typedResponse.url = options.url.toString();\n    typedResponse.requestUrl = this.requestUrl;\n    typedResponse.redirectUrls = this.redirectUrls;\n    typedResponse.request = this;\n    typedResponse.isFromCache = (_this$_nativeResponse = this._nativeResponse.fromCache) !== null && _this$_nativeResponse !== void 0 ? _this$_nativeResponse : false;\n    typedResponse.ip = this.ip;\n    typedResponse.retryCount = this.retryCount;\n    typedResponse.ok = isResponseOk(typedResponse);\n    this._isFromCache = typedResponse.isFromCache;\n    this._responseSize = Number(response.headers['content-length']) || undefined;\n    this.response = typedResponse;\n    response.once('end', () => {\n      this._responseSize = this._downloadedSize;\n      this.emit('downloadProgress', this.downloadProgress);\n    });\n    response.once('error', error => {\n      this._aborted = true;\n      // Force clean-up, because some packages don't do this.\n      // TODO: Fix decompress-response\n      response.destroy();\n      this._beforeError(new ReadError(error, this));\n    });\n    response.once('aborted', () => {\n      this._aborted = true;\n      this._beforeError(new ReadError({\n        name: 'Error',\n        message: 'The server aborted pending request',\n        code: 'ECONNRESET'\n      }, this));\n    });\n    this.emit('downloadProgress', this.downloadProgress);\n    const rawCookies = response.headers['set-cookie'];\n    if (is.object(options.cookieJar) && rawCookies) {\n      let promises = rawCookies.map(async rawCookie => options.cookieJar.setCookie(rawCookie, url.toString()));\n      if (options.ignoreInvalidCookies) {\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        promises = promises.map(async promise => {\n          try {\n            await promise;\n          } catch (_unused) {}\n        });\n      }\n      try {\n        await Promise.all(promises);\n      } catch (error) {\n        this._beforeError(error);\n        return;\n      }\n    }\n    // The above is running a promise, therefore we need to check if this request has been aborted yet again.\n    if (this.isAborted) {\n      return;\n    }\n    if (response.headers.location && redirectCodes.has(statusCode)) {\n      // We're being redirected, we don't care about the response.\n      // It'd be best to abort the request, but we can't because\n      // we would have to sacrifice the TCP connection. We don't want that.\n      const shouldFollow = typeof options.followRedirect === 'function' ? options.followRedirect(typedResponse) : options.followRedirect;\n      if (shouldFollow) {\n        response.resume();\n        this._cancelTimeouts();\n        this._unproxyEvents();\n        if (this.redirectUrls.length >= options.maxRedirects) {\n          this._beforeError(new MaxRedirectsError(this));\n          return;\n        }\n        this._request = undefined;\n        const updatedOptions = new Options(undefined, undefined, this.options);\n        const serverRequestedGet = statusCode === 303 && updatedOptions.method !== 'GET' && updatedOptions.method !== 'HEAD';\n        const canRewrite = statusCode !== 307 && statusCode !== 308;\n        const userRequestedGet = updatedOptions.methodRewriting && canRewrite;\n        if (serverRequestedGet || userRequestedGet) {\n          updatedOptions.method = 'GET';\n          updatedOptions.body = undefined;\n          updatedOptions.json = undefined;\n          updatedOptions.form = undefined;\n          delete updatedOptions.headers['content-length'];\n        }\n        try {\n          // We need this in order to support UTF-8\n          const redirectBuffer = Buffer.from(response.headers.location, 'binary').toString();\n          const redirectUrl = new URL(redirectBuffer, url);\n          if (!isUnixSocketURL(url) && isUnixSocketURL(redirectUrl)) {\n            this._beforeError(new RequestError('Cannot redirect to UNIX socket', {}, this));\n            return;\n          }\n          // Redirecting to a different site, clear sensitive data.\n          if (redirectUrl.hostname !== url.hostname || redirectUrl.port !== url.port) {\n            if ('host' in updatedOptions.headers) {\n              delete updatedOptions.headers.host;\n            }\n            if ('cookie' in updatedOptions.headers) {\n              delete updatedOptions.headers.cookie;\n            }\n            if ('authorization' in updatedOptions.headers) {\n              delete updatedOptions.headers.authorization;\n            }\n            if (updatedOptions.username || updatedOptions.password) {\n              updatedOptions.username = '';\n              updatedOptions.password = '';\n            }\n          } else {\n            redirectUrl.username = updatedOptions.username;\n            redirectUrl.password = updatedOptions.password;\n          }\n          this.redirectUrls.push(redirectUrl);\n          updatedOptions.prefixUrl = '';\n          updatedOptions.url = redirectUrl;\n          for (const hook of updatedOptions.hooks.beforeRedirect) {\n            // eslint-disable-next-line no-await-in-loop\n            await hook(updatedOptions, typedResponse);\n          }\n          this.emit('redirect', updatedOptions, typedResponse);\n          this.options = updatedOptions;\n          await this._makeRequest();\n        } catch (error) {\n          this._beforeError(error);\n          return;\n        }\n        return;\n      }\n    }\n    // `HTTPError`s always have `error.response.body` defined.\n    // Therefore, we cannot retry if `options.throwHttpErrors` is false.\n    // On the last retry, if `options.throwHttpErrors` is false, we would need to return the body,\n    // but that wouldn't be possible since the body would be already read in `error.response.body`.\n    if (options.isStream && options.throwHttpErrors && !isResponseOk(typedResponse)) {\n      this._beforeError(new HTTPError(typedResponse));\n      return;\n    }\n    response.on('readable', () => {\n      if (this._triggerRead) {\n        this._read();\n      }\n    });\n    this.on('resume', () => {\n      response.resume();\n    });\n    this.on('pause', () => {\n      response.pause();\n    });\n    response.once('end', () => {\n      this.push(null);\n    });\n    if (this._noPipe) {\n      const success = await this._setRawBody();\n      if (success) {\n        this.emit('response', response);\n      }\n      return;\n    }\n    this.emit('response', response);\n    for (const destination of this._pipedServerResponses) {\n      if (destination.headersSent) {\n        continue;\n      }\n      // eslint-disable-next-line guard-for-in\n      for (const key in response.headers) {\n        const isAllowed = options.decompress ? key !== 'content-encoding' : true;\n        const value = response.headers[key];\n        if (isAllowed) {\n          destination.setHeader(key, value);\n        }\n      }\n      destination.statusCode = statusCode;\n    }\n  }\n  async _setRawBody() {\n    let from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this;\n    if (from.readableEnded) {\n      return false;\n    }\n    try {\n      // Errors are emitted via the `error` event\n      const fromArray = await from.toArray();\n      const rawBody = isBuffer(fromArray.at(0)) ? Buffer.concat(fromArray) : Buffer.from(fromArray.join(''));\n      // On retry Request is destroyed with no error, therefore the above will successfully resolve.\n      // So in order to check if this was really successfull, we need to check if it has been properly ended.\n      if (!this.isAborted) {\n        this.response.rawBody = rawBody;\n        return true;\n      }\n    } catch (_unused2) {}\n    return false;\n  }\n  async _onResponse(response) {\n    try {\n      await this._onResponseBase(response);\n    } catch (error) {\n      /* istanbul ignore next: better safe than sorry */\n      this._beforeError(error);\n    }\n  }\n  _onRequest(request) {\n    const {\n      options\n    } = this;\n    const {\n      timeout,\n      url\n    } = options;\n    timer(request);\n    if (this.options.http2) {\n      // Unset stream timeout, as the `timeout` option was used only for connection timeout.\n      request.setTimeout(0);\n    }\n    this._cancelTimeouts = timedOut(request, timeout, url);\n    const responseEventName = options.cache ? 'cacheableResponse' : 'response';\n    request.once(responseEventName, response => {\n      void this._onResponse(response);\n    });\n    request.once('error', error => {\n      this._aborted = true;\n      // Force clean-up, because some packages (e.g. nock) don't do this.\n      request.destroy();\n      error = error instanceof TimedOutTimeoutError ? new TimeoutError(error, this.timings, this) : new RequestError(error.message, error, this);\n      this._beforeError(error);\n    });\n    this._unproxyEvents = proxyEvents(request, this, proxiedRequestEvents);\n    this._request = request;\n    this.emit('uploadProgress', this.uploadProgress);\n    this._sendBody();\n    this.emit('request', request);\n  }\n  async _asyncWrite(chunk) {\n    return new Promise((resolve, reject) => {\n      super.write(chunk, error => {\n        if (error) {\n          reject(error);\n          return;\n        }\n        resolve();\n      });\n    });\n  }\n  _sendBody() {\n    var _this$_request5;\n    // Send body\n    const {\n      body\n    } = this.options;\n    const currentRequest = this.redirectUrls.length === 0 ? this : (_this$_request5 = this._request) !== null && _this$_request5 !== void 0 ? _this$_request5 : this;\n    if (is.nodeStream(body)) {\n      body.pipe(currentRequest);\n    } else if (is.generator(body) || is.asyncGenerator(body)) {\n      (async () => {\n        try {\n          var _iteratorAbruptCompletion = false;\n          var _didIteratorError = false;\n          var _iteratorError;\n          try {\n            for (var _iterator = _asyncIterator(body), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {\n              const chunk = _step.value;\n              {\n                await this._asyncWrite(chunk);\n              }\n            }\n          } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n          } finally {\n            try {\n              if (_iteratorAbruptCompletion && _iterator.return != null) {\n                await _iterator.return();\n              }\n            } finally {\n              if (_didIteratorError) {\n                throw _iteratorError;\n              }\n            }\n          }\n          super.end();\n        } catch (error) {\n          this._beforeError(error);\n        }\n      })();\n    } else if (!is.undefined(body)) {\n      this._writeRequest(body, undefined, () => {});\n      currentRequest.end();\n    } else if (this._cannotHaveBody || this._noPipe) {\n      currentRequest.end();\n    }\n  }\n  _prepareCache(cache) {\n    if (!cacheableStore.has(cache)) {\n      const cacheableRequest = new CacheableRequest((requestOptions, handler) => {\n        const result = requestOptions._request(requestOptions, handler);\n        // TODO: remove this when `cacheable-request` supports async request functions.\n        if (is.promise(result)) {\n          // We only need to implement the error handler in order to support HTTP2 caching.\n          // The result will be a promise anyway.\n          // @ts-expect-error ignore\n          result.once = (event, handler) => {\n            if (event === 'error') {\n              (async () => {\n                try {\n                  await result;\n                } catch (error) {\n                  handler(error);\n                }\n              })();\n            } else if (event === 'abort' || event === 'destroy') {\n              // The empty catch is needed here in case when\n              // it rejects before it's `await`ed in `_makeRequest`.\n              (async () => {\n                try {\n                  const request = await result;\n                  request.once(event, handler);\n                } catch (_unused3) {}\n              })();\n            } else {\n              /* istanbul ignore next: safety check */\n              throw new Error(\"Unknown HTTP2 promise event: \".concat(event));\n            }\n            return result;\n          };\n        }\n        return result;\n      }, cache);\n      cacheableStore.set(cache, cacheableRequest.request());\n    }\n  }\n  async _createCacheableRequest(url, options) {\n    return new Promise((resolve, reject) => {\n      // TODO: Remove `utils/url-to-options.ts` when `cacheable-request` is fixed\n      Object.assign(options, urlToOptions(url));\n      let request;\n      // TODO: Fix `cacheable-response`. This is ugly.\n      const cacheRequest = cacheableStore.get(options.cache)(options, async response => {\n        response._readableState.autoDestroy = false;\n        if (request) {\n          const fix = () => {\n            if (response.req) {\n              response.complete = response.req.res.complete;\n            }\n          };\n          response.prependOnceListener('end', fix);\n          fix();\n          (await request).emit('cacheableResponse', response);\n        }\n        resolve(response);\n      });\n      cacheRequest.once('error', reject);\n      cacheRequest.once('request', async requestOrPromise => {\n        request = requestOrPromise;\n        resolve(request);\n      });\n    });\n  }\n  async _makeRequest() {\n    const {\n      options\n    } = this;\n    const {\n      headers,\n      username,\n      password\n    } = options;\n    const cookieJar = options.cookieJar;\n    for (const key in headers) {\n      if (is.undefined(headers[key])) {\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n        delete headers[key];\n      } else if (is.null(headers[key])) {\n        throw new TypeError(\"Use `undefined` instead of `null` to delete the `\".concat(key, \"` header\"));\n      }\n    }\n    if (options.decompress && is.undefined(headers['accept-encoding'])) {\n      headers['accept-encoding'] = supportsBrotli ? 'gzip, deflate, br' : 'gzip, deflate';\n    }\n    if (username || password) {\n      const credentials = Buffer.from(\"\".concat(username, \":\").concat(password)).toString('base64');\n      headers.authorization = \"Basic \".concat(credentials);\n    }\n    // Set cookies\n    if (cookieJar) {\n      const cookieString = await cookieJar.getCookieString(options.url.toString());\n      if (is.nonEmptyString(cookieString)) {\n        headers.cookie = cookieString;\n      }\n    }\n    // Reset `prefixUrl`\n    options.prefixUrl = '';\n    let request;\n    for (const hook of options.hooks.beforeRequest) {\n      // eslint-disable-next-line no-await-in-loop\n      const result = await hook(options);\n      if (!is.undefined(result)) {\n        // @ts-expect-error Skip the type mismatch to support abstract responses\n        request = () => result;\n        break;\n      }\n    }\n    request || (request = options.getRequestFunction());\n    const url = options.url;\n    this._requestOptions = options.createNativeRequestOptions();\n    if (options.cache) {\n      this._requestOptions._request = request;\n      this._requestOptions.cache = options.cache;\n      this._requestOptions.body = options.body;\n      this._prepareCache(options.cache);\n    }\n    // Cache support\n    const function_ = options.cache ? this._createCacheableRequest : request;\n    try {\n      // We can't do `await fn(...)`,\n      // because stream `error` event can be emitted before `Promise.resolve()`.\n      let requestOrResponse = function_(url, this._requestOptions);\n      if (is.promise(requestOrResponse)) {\n        requestOrResponse = await requestOrResponse;\n      }\n      // Fallback\n      if (is.undefined(requestOrResponse)) {\n        requestOrResponse = options.getFallbackRequestFunction()(url, this._requestOptions);\n        if (is.promise(requestOrResponse)) {\n          requestOrResponse = await requestOrResponse;\n        }\n      }\n      if (isClientRequest(requestOrResponse)) {\n        this._onRequest(requestOrResponse);\n      } else if (this.writable) {\n        this.once('finish', () => {\n          void this._onResponse(requestOrResponse);\n        });\n        this._sendBody();\n      } else {\n        void this._onResponse(requestOrResponse);\n      }\n    } catch (error) {\n      if (error instanceof CacheableCacheError) {\n        throw new CacheError(error, this);\n      }\n      throw error;\n    }\n  }\n  async _error(error) {\n    try {\n      if (error instanceof HTTPError && !this.options.throwHttpErrors) {\n        // This branch can be reached only when using the Promise API\n        // Skip calling the hooks on purpose.\n        // See https://github.com/sindresorhus/got/issues/2103\n      } else {\n        for (const hook of this.options.hooks.beforeError) {\n          // eslint-disable-next-line no-await-in-loop\n          error = await hook(error);\n        }\n      }\n    } catch (error_) {\n      error = new RequestError(error_.message, error_, this);\n    }\n    this.destroy(error);\n  }\n  _writeRequest(chunk, encoding, callback) {\n    if (!this._request || this._request.destroyed) {\n      // Probably the `ClientRequest` instance will throw\n      return;\n    }\n    this._request.write(chunk, encoding, error => {\n      // The `!destroyed` check is required to prevent `uploadProgress` being emitted after the stream was destroyed\n      if (!error && !this._request.destroyed) {\n        this._uploadedSize += Buffer.byteLength(chunk, encoding);\n        const progress = this.uploadProgress;\n        if (progress.percent < 1) {\n          this.emit('uploadProgress', progress);\n        }\n      }\n      callback(error);\n    });\n  }\n  /**\n  The remote IP address.\n  */\n  get ip() {\n    var _this$socket;\n    return (_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : _this$socket.remoteAddress;\n  }\n  /**\n  Indicates whether the request has been aborted or not.\n  */\n  get isAborted() {\n    return this._aborted;\n  }\n  get socket() {\n    var _this$_request$socket, _this$_request6;\n    return (_this$_request$socket = (_this$_request6 = this._request) === null || _this$_request6 === void 0 ? void 0 : _this$_request6.socket) !== null && _this$_request$socket !== void 0 ? _this$_request$socket : undefined;\n  }\n  /**\n  Progress event for downloading (receiving a response).\n  */\n  get downloadProgress() {\n    let percent;\n    if (this._responseSize) {\n      percent = this._downloadedSize / this._responseSize;\n    } else if (this._responseSize === this._downloadedSize) {\n      percent = 1;\n    } else {\n      percent = 0;\n    }\n    return {\n      percent,\n      transferred: this._downloadedSize,\n      total: this._responseSize\n    };\n  }\n  /**\n  Progress event for uploading (sending a request).\n  */\n  get uploadProgress() {\n    let percent;\n    if (this._bodySize) {\n      percent = this._uploadedSize / this._bodySize;\n    } else if (this._bodySize === this._uploadedSize) {\n      percent = 1;\n    } else {\n      percent = 0;\n    }\n    return {\n      percent,\n      transferred: this._uploadedSize,\n      total: this._bodySize\n    };\n  }\n  /**\n  The object contains the following properties:\n   - `start` - Time when the request started.\n  - `socket` - Time when a socket was assigned to the request.\n  - `lookup` - Time when the DNS lookup finished.\n  - `connect` - Time when the socket successfully connected.\n  - `secureConnect` - Time when the socket securely connected.\n  - `upload` - Time when the request finished uploading.\n  - `response` - Time when the request fired `response` event.\n  - `end` - Time when the response fired `end` event.\n  - `error` - Time when the request fired `error` event.\n  - `abort` - Time when the request fired `abort` event.\n  - `phases`\n      - `wait` - `timings.socket - timings.start`\n      - `dns` - `timings.lookup - timings.socket`\n      - `tcp` - `timings.connect - timings.lookup`\n      - `tls` - `timings.secureConnect - timings.connect`\n      - `request` - `timings.upload - (timings.secureConnect || timings.connect)`\n      - `firstByte` - `timings.response - timings.upload`\n      - `download` - `timings.end - timings.response`\n      - `total` - `(timings.end || timings.error || timings.abort) - timings.start`\n   If something has not been measured yet, it will be `undefined`.\n   __Note__: The time is a `number` representing the milliseconds elapsed since the UNIX epoch.\n  */\n  get timings() {\n    var _this$_request7;\n    return (_this$_request7 = this._request) === null || _this$_request7 === void 0 ? void 0 : _this$_request7.timings;\n  }\n  /**\n  Whether the response was retrieved from the cache.\n  */\n  get isFromCache() {\n    return this._isFromCache;\n  }\n  get reusedSocket() {\n    var _this$_request8;\n    return (_this$_request8 = this._request) === null || _this$_request8 === void 0 ? void 0 : _this$_request8.reusedSocket;\n  }\n}","map":{"version":3,"names":["process","Buffer","Duplex","http","ServerResponse","timer","CacheableRequest","CacheError","CacheableCacheError","decompressResponse","is","isBuffer","FormDataEncoder","isFormData","isFormDataLike","getBodySize","proxyEvents","timedOut","TimeoutError","TimedOutTimeoutError","urlToOptions","WeakableMap","calculateRetryDelay","Options","isResponseOk","isClientRequest","isUnixSocketURL","RequestError","ReadError","MaxRedirectsError","HTTPError","UploadError","AbortError","supportsBrotli","string","versions","brotli","methodsWithoutBody","Set","cacheableStore","redirectCodes","proxiedRequestEvents","noop","Request","constructor","url","options","defaults","autoDestroy","highWaterMark","_defineProperty","_downloadedSize","_uploadedSize","_stopReading","_pipedServerResponses","_cannotHaveBody","_unproxyEvents","_triggerRead","_cancelTimeouts","_removeListeners","_jobs","_flushed","_requestInitialized","_aborted","redirectUrls","retryCount","_stopRetry","on","source","headers","Object","assign","event","listenerCount","Error","prefixUrl","TypeError","requestUrl","error","flush","destroy","body","nodeStream","once","_beforeError","signal","abort","_this$options$signal","reason","name","timings","aborted","addEventListener","_this$options$signal2","removeEventListener","_finalizeBody","destroyed","_makeRequest","_this$_request","_request","job","length","response","attemptCount","message","typedError","_this$_request2","readable","rawBody","socket","setEncoding","readableEncoding","success","_setRawBody","toString","backoff","_ref","_retryOptions$maxRetr","retryAfter","Number","isNaN","Date","parse","now","retryOptions","retry","calculateDelay","computedValue","maxRetryAfter","timeout","request","POSITIVE_INFINITY","error_","_error","Promise","resolve","setTimeout","clearTimeout","hook","hooks","beforeRetry","emit","updatedOptions","nextTick","_read","readableLength","data","read","progress","downloadProgress","percent","push","_write","chunk","encoding","callback","write","_writeRequest","_final","endRequest","end","_this$_request3","_writableState","errored","_this$_request4","_bodySize","uploadProgress","_destroy","undefined","pipe","destination","add","unpipe","delete","isForm","form","isJSON","json","isBody","cannotHaveBody","has","method","allowGetBody","concat","noContentType","encoder","encode","getBoundary","URLSearchParams","stringifyJson","uploadBodySize","String","responseType","accept","_onResponseBase","_typedResponse$status","_this$_nativeResponse","isAborted","_nativeResponse","decompress","statusCode","typedResponse","statusMessage","STATUS_CODES","isFromCache","fromCache","ip","ok","_isFromCache","_responseSize","code","rawCookies","object","cookieJar","promises","map","rawCookie","setCookie","ignoreInvalidCookies","promise","_unused","all","location","shouldFollow","followRedirect","resume","maxRedirects","serverRequestedGet","canRewrite","userRequestedGet","methodRewriting","redirectBuffer","from","redirectUrl","URL","hostname","port","host","cookie","authorization","username","password","beforeRedirect","isStream","throwHttpErrors","pause","_noPipe","headersSent","key","isAllowed","value","setHeader","arguments","readableEnded","fromArray","toArray","at","join","_unused2","_onResponse","_onRequest","http2","responseEventName","cache","_sendBody","_asyncWrite","reject","_this$_request5","currentRequest","generator","asyncGenerator","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_asyncIterator","_step","next","done","err","return","_prepareCache","cacheableRequest","requestOptions","handler","result","_unused3","set","_createCacheableRequest","cacheRequest","get","_readableState","fix","req","complete","res","prependOnceListener","requestOrPromise","null","credentials","cookieString","getCookieString","nonEmptyString","beforeRequest","getRequestFunction","_requestOptions","createNativeRequestOptions","function_","requestOrResponse","getFallbackRequestFunction","writable","beforeError","byteLength","_this$socket","remoteAddress","_this$_request$socket","_this$_request6","transferred","total","_this$_request7","reusedSocket","_this$_request8"],"sources":["C:/Users/sakas/OneDrive/Desktop/gogo/node_modules/got/dist/source/core/index.js"],"sourcesContent":["import process from 'node:process';\nimport { Buffer } from 'node:buffer';\nimport { Duplex } from 'node:stream';\nimport http, { ServerResponse } from 'node:http';\nimport timer from '@szmarczak/http-timer';\nimport CacheableRequest, { CacheError as CacheableCacheError, } from 'cacheable-request';\nimport decompressResponse from 'decompress-response';\nimport is, { isBuffer } from '@sindresorhus/is';\nimport { FormDataEncoder, isFormData as isFormDataLike } from 'form-data-encoder';\nimport getBodySize from './utils/get-body-size.js';\nimport isFormData from './utils/is-form-data.js';\nimport proxyEvents from './utils/proxy-events.js';\nimport timedOut, { TimeoutError as TimedOutTimeoutError } from './timed-out.js';\nimport urlToOptions from './utils/url-to-options.js';\nimport WeakableMap from './utils/weakable-map.js';\nimport calculateRetryDelay from './calculate-retry-delay.js';\nimport Options from './options.js';\nimport { isResponseOk } from './response.js';\nimport isClientRequest from './utils/is-client-request.js';\nimport isUnixSocketURL from './utils/is-unix-socket-url.js';\nimport { RequestError, ReadError, MaxRedirectsError, HTTPError, TimeoutError, UploadError, CacheError, AbortError, } from './errors.js';\nconst supportsBrotli = is.string(process.versions.brotli);\nconst methodsWithoutBody = new Set(['GET', 'HEAD']);\nconst cacheableStore = new WeakableMap();\nconst redirectCodes = new Set([300, 301, 302, 303, 304, 307, 308]);\nconst proxiedRequestEvents = [\n    'socket',\n    'connect',\n    'continue',\n    'information',\n    'upgrade',\n];\nconst noop = () => { };\nexport default class Request extends Duplex {\n    // @ts-expect-error - Ignoring for now.\n    ['constructor'];\n    _noPipe;\n    // @ts-expect-error https://github.com/microsoft/TypeScript/issues/9568\n    options;\n    response;\n    requestUrl;\n    redirectUrls;\n    retryCount;\n    _stopRetry;\n    _downloadedSize;\n    _uploadedSize;\n    _stopReading;\n    _pipedServerResponses;\n    _request;\n    _responseSize;\n    _bodySize;\n    _unproxyEvents;\n    _isFromCache;\n    _cannotHaveBody;\n    _triggerRead;\n    _cancelTimeouts;\n    _removeListeners;\n    _nativeResponse;\n    _flushed;\n    _aborted;\n    // We need this because `this._request` if `undefined` when using cache\n    _requestInitialized;\n    constructor(url, options, defaults) {\n        super({\n            // Don't destroy immediately, as the error may be emitted on unsuccessful retry\n            autoDestroy: false,\n            // It needs to be zero because we're just proxying the data to another stream\n            highWaterMark: 0,\n        });\n        this._downloadedSize = 0;\n        this._uploadedSize = 0;\n        this._stopReading = false;\n        this._pipedServerResponses = new Set();\n        this._cannotHaveBody = false;\n        this._unproxyEvents = noop;\n        this._triggerRead = false;\n        this._cancelTimeouts = noop;\n        this._removeListeners = noop;\n        this._jobs = [];\n        this._flushed = false;\n        this._requestInitialized = false;\n        this._aborted = false;\n        this.redirectUrls = [];\n        this.retryCount = 0;\n        this._stopRetry = noop;\n        this.on('pipe', (source) => {\n            if (source?.headers) {\n                Object.assign(this.options.headers, source.headers);\n            }\n        });\n        this.on('newListener', event => {\n            if (event === 'retry' && this.listenerCount('retry') > 0) {\n                throw new Error('A retry listener has been attached already.');\n            }\n        });\n        try {\n            this.options = new Options(url, options, defaults);\n            if (!this.options.url) {\n                if (this.options.prefixUrl === '') {\n                    throw new TypeError('Missing `url` property');\n                }\n                this.options.url = '';\n            }\n            this.requestUrl = this.options.url;\n        }\n        catch (error) {\n            const { options } = error;\n            if (options) {\n                this.options = options;\n            }\n            this.flush = async () => {\n                this.flush = async () => { };\n                this.destroy(error);\n            };\n            return;\n        }\n        // Important! If you replace `body` in a handler with another stream, make sure it's readable first.\n        // The below is run only once.\n        const { body } = this.options;\n        if (is.nodeStream(body)) {\n            body.once('error', error => {\n                if (this._flushed) {\n                    this._beforeError(new UploadError(error, this));\n                }\n                else {\n                    this.flush = async () => {\n                        this.flush = async () => { };\n                        this._beforeError(new UploadError(error, this));\n                    };\n                }\n            });\n        }\n        if (this.options.signal) {\n            const abort = () => {\n                // See https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/timeout_static#return_value\n                if (this.options.signal?.reason?.name === 'TimeoutError') {\n                    this.destroy(new TimeoutError(this.options.signal.reason, this.timings, this));\n                }\n                else {\n                    this.destroy(new AbortError(this));\n                }\n            };\n            if (this.options.signal.aborted) {\n                abort();\n            }\n            else {\n                this.options.signal.addEventListener('abort', abort);\n                this._removeListeners = () => {\n                    this.options.signal?.removeEventListener('abort', abort);\n                };\n            }\n        }\n    }\n    async flush() {\n        if (this._flushed) {\n            return;\n        }\n        this._flushed = true;\n        try {\n            await this._finalizeBody();\n            if (this.destroyed) {\n                return;\n            }\n            await this._makeRequest();\n            if (this.destroyed) {\n                this._request?.destroy();\n                return;\n            }\n            // Queued writes etc.\n            for (const job of this._jobs) {\n                job();\n            }\n            // Prevent memory leak\n            this._jobs.length = 0;\n            this._requestInitialized = true;\n        }\n        catch (error) {\n            this._beforeError(error);\n        }\n    }\n    _beforeError(error) {\n        if (this._stopReading) {\n            return;\n        }\n        const { response, options } = this;\n        const attemptCount = this.retryCount + (error.name === 'RetryError' ? 0 : 1);\n        this._stopReading = true;\n        if (!(error instanceof RequestError)) {\n            error = new RequestError(error.message, error, this);\n        }\n        const typedError = error;\n        void (async () => {\n            // Node.js parser is really weird.\n            // It emits post-request Parse Errors on the same instance as previous request. WTF.\n            // Therefore, we need to check if it has been destroyed as well.\n            //\n            // Furthermore, Node.js 16 `response.destroy()` doesn't immediately destroy the socket,\n            // but makes the response unreadable. So we additionally need to check `response.readable`.\n            if (response?.readable && !response.rawBody && !this._request?.socket?.destroyed) {\n                // @types/node has incorrect typings. `setEncoding` accepts `null` as well.\n                response.setEncoding(this.readableEncoding);\n                const success = await this._setRawBody(response);\n                if (success) {\n                    response.body = response.rawBody.toString();\n                }\n            }\n            if (this.listenerCount('retry') !== 0) {\n                let backoff;\n                try {\n                    let retryAfter;\n                    if (response && 'retry-after' in response.headers) {\n                        retryAfter = Number(response.headers['retry-after']);\n                        if (Number.isNaN(retryAfter)) {\n                            retryAfter = Date.parse(response.headers['retry-after']) - Date.now();\n                            if (retryAfter <= 0) {\n                                retryAfter = 1;\n                            }\n                        }\n                        else {\n                            retryAfter *= 1000;\n                        }\n                    }\n                    const retryOptions = options.retry;\n                    backoff = await retryOptions.calculateDelay({\n                        attemptCount,\n                        retryOptions,\n                        error: typedError,\n                        retryAfter,\n                        computedValue: calculateRetryDelay({\n                            attemptCount,\n                            retryOptions,\n                            error: typedError,\n                            retryAfter,\n                            computedValue: retryOptions.maxRetryAfter ?? options.timeout.request ?? Number.POSITIVE_INFINITY,\n                        }),\n                    });\n                }\n                catch (error_) {\n                    void this._error(new RequestError(error_.message, error_, this));\n                    return;\n                }\n                if (backoff) {\n                    await new Promise(resolve => {\n                        const timeout = setTimeout(resolve, backoff);\n                        this._stopRetry = () => {\n                            clearTimeout(timeout);\n                            resolve();\n                        };\n                    });\n                    // Something forced us to abort the retry\n                    if (this.destroyed) {\n                        return;\n                    }\n                    try {\n                        for (const hook of this.options.hooks.beforeRetry) {\n                            // eslint-disable-next-line no-await-in-loop\n                            await hook(typedError, this.retryCount + 1);\n                        }\n                    }\n                    catch (error_) {\n                        void this._error(new RequestError(error_.message, error, this));\n                        return;\n                    }\n                    // Something forced us to abort the retry\n                    if (this.destroyed) {\n                        return;\n                    }\n                    this.destroy();\n                    this.emit('retry', this.retryCount + 1, error, (updatedOptions) => {\n                        const request = new Request(options.url, updatedOptions, options);\n                        request.retryCount = this.retryCount + 1;\n                        process.nextTick(() => {\n                            void request.flush();\n                        });\n                        return request;\n                    });\n                    return;\n                }\n            }\n            void this._error(typedError);\n        })();\n    }\n    _read() {\n        this._triggerRead = true;\n        const { response } = this;\n        if (response && !this._stopReading) {\n            // We cannot put this in the `if` above\n            // because `.read()` also triggers the `end` event\n            if (response.readableLength) {\n                this._triggerRead = false;\n            }\n            let data;\n            while ((data = response.read()) !== null) {\n                this._downloadedSize += data.length; // eslint-disable-line @typescript-eslint/restrict-plus-operands\n                const progress = this.downloadProgress;\n                if (progress.percent < 1) {\n                    this.emit('downloadProgress', progress);\n                }\n                this.push(data);\n            }\n        }\n    }\n    _write(chunk, encoding, callback) {\n        const write = () => {\n            this._writeRequest(chunk, encoding, callback);\n        };\n        if (this._requestInitialized) {\n            write();\n        }\n        else {\n            this._jobs.push(write);\n        }\n    }\n    _final(callback) {\n        const endRequest = () => {\n            // We need to check if `this._request` is present,\n            // because it isn't when we use cache.\n            if (!this._request || this._request.destroyed) {\n                callback();\n                return;\n            }\n            this._request.end((error) => {\n                // The request has been destroyed before `_final` finished.\n                // See https://github.com/nodejs/node/issues/39356\n                if (this._request?._writableState?.errored) {\n                    return;\n                }\n                if (!error) {\n                    this._bodySize = this._uploadedSize;\n                    this.emit('uploadProgress', this.uploadProgress);\n                    this._request?.emit('upload-complete');\n                }\n                callback(error);\n            });\n        };\n        if (this._requestInitialized) {\n            endRequest();\n        }\n        else {\n            this._jobs.push(endRequest);\n        }\n    }\n    _destroy(error, callback) {\n        this._stopReading = true;\n        this.flush = async () => { };\n        // Prevent further retries\n        this._stopRetry();\n        this._cancelTimeouts();\n        this._removeListeners();\n        if (this.options) {\n            const { body } = this.options;\n            if (is.nodeStream(body)) {\n                body.destroy();\n            }\n        }\n        if (this._request) {\n            this._request.destroy();\n        }\n        if (error !== null && !is.undefined(error) && !(error instanceof RequestError)) {\n            error = new RequestError(error.message, error, this);\n        }\n        callback(error);\n    }\n    pipe(destination, options) {\n        if (destination instanceof ServerResponse) {\n            this._pipedServerResponses.add(destination);\n        }\n        return super.pipe(destination, options);\n    }\n    unpipe(destination) {\n        if (destination instanceof ServerResponse) {\n            this._pipedServerResponses.delete(destination);\n        }\n        super.unpipe(destination);\n        return this;\n    }\n    async _finalizeBody() {\n        const { options } = this;\n        const { headers } = options;\n        const isForm = !is.undefined(options.form);\n        // eslint-disable-next-line @typescript-eslint/naming-convention\n        const isJSON = !is.undefined(options.json);\n        const isBody = !is.undefined(options.body);\n        const cannotHaveBody = methodsWithoutBody.has(options.method) && !(options.method === 'GET' && options.allowGetBody);\n        this._cannotHaveBody = cannotHaveBody;\n        if (isForm || isJSON || isBody) {\n            if (cannotHaveBody) {\n                throw new TypeError(`The \\`${options.method}\\` method cannot be used with a body`);\n            }\n            // Serialize body\n            const noContentType = !is.string(headers['content-type']);\n            if (isBody) {\n                // Body is spec-compliant FormData\n                if (isFormDataLike(options.body)) {\n                    const encoder = new FormDataEncoder(options.body);\n                    if (noContentType) {\n                        headers['content-type'] = encoder.headers['Content-Type'];\n                    }\n                    if ('Content-Length' in encoder.headers) {\n                        headers['content-length'] = encoder.headers['Content-Length'];\n                    }\n                    options.body = encoder.encode();\n                }\n                // Special case for https://github.com/form-data/form-data\n                if (isFormData(options.body) && noContentType) {\n                    headers['content-type'] = `multipart/form-data; boundary=${options.body.getBoundary()}`;\n                }\n            }\n            else if (isForm) {\n                if (noContentType) {\n                    headers['content-type'] = 'application/x-www-form-urlencoded';\n                }\n                const { form } = options;\n                options.form = undefined;\n                options.body = (new URLSearchParams(form)).toString();\n            }\n            else {\n                if (noContentType) {\n                    headers['content-type'] = 'application/json';\n                }\n                const { json } = options;\n                options.json = undefined;\n                options.body = options.stringifyJson(json);\n            }\n            const uploadBodySize = await getBodySize(options.body, options.headers);\n            // See https://tools.ietf.org/html/rfc7230#section-3.3.2\n            // A user agent SHOULD send a Content-Length in a request message when\n            // no Transfer-Encoding is sent and the request method defines a meaning\n            // for an enclosed payload body.  For example, a Content-Length header\n            // field is normally sent in a POST request even when the value is 0\n            // (indicating an empty payload body).  A user agent SHOULD NOT send a\n            // Content-Length header field when the request message does not contain\n            // a payload body and the method semantics do not anticipate such a\n            // body.\n            if (is.undefined(headers['content-length']) && is.undefined(headers['transfer-encoding']) && !cannotHaveBody && !is.undefined(uploadBodySize)) {\n                headers['content-length'] = String(uploadBodySize);\n            }\n        }\n        if (options.responseType === 'json' && !('accept' in options.headers)) {\n            options.headers.accept = 'application/json';\n        }\n        this._bodySize = Number(headers['content-length']) || undefined;\n    }\n    async _onResponseBase(response) {\n        // This will be called e.g. when using cache so we need to check if this request has been aborted.\n        if (this.isAborted) {\n            return;\n        }\n        const { options } = this;\n        const { url } = options;\n        this._nativeResponse = response;\n        if (options.decompress) {\n            response = decompressResponse(response);\n        }\n        const statusCode = response.statusCode;\n        const typedResponse = response;\n        typedResponse.statusMessage = typedResponse.statusMessage ?? http.STATUS_CODES[statusCode];\n        typedResponse.url = options.url.toString();\n        typedResponse.requestUrl = this.requestUrl;\n        typedResponse.redirectUrls = this.redirectUrls;\n        typedResponse.request = this;\n        typedResponse.isFromCache = this._nativeResponse.fromCache ?? false;\n        typedResponse.ip = this.ip;\n        typedResponse.retryCount = this.retryCount;\n        typedResponse.ok = isResponseOk(typedResponse);\n        this._isFromCache = typedResponse.isFromCache;\n        this._responseSize = Number(response.headers['content-length']) || undefined;\n        this.response = typedResponse;\n        response.once('end', () => {\n            this._responseSize = this._downloadedSize;\n            this.emit('downloadProgress', this.downloadProgress);\n        });\n        response.once('error', (error) => {\n            this._aborted = true;\n            // Force clean-up, because some packages don't do this.\n            // TODO: Fix decompress-response\n            response.destroy();\n            this._beforeError(new ReadError(error, this));\n        });\n        response.once('aborted', () => {\n            this._aborted = true;\n            this._beforeError(new ReadError({\n                name: 'Error',\n                message: 'The server aborted pending request',\n                code: 'ECONNRESET',\n            }, this));\n        });\n        this.emit('downloadProgress', this.downloadProgress);\n        const rawCookies = response.headers['set-cookie'];\n        if (is.object(options.cookieJar) && rawCookies) {\n            let promises = rawCookies.map(async (rawCookie) => options.cookieJar.setCookie(rawCookie, url.toString()));\n            if (options.ignoreInvalidCookies) {\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises\n                promises = promises.map(async (promise) => {\n                    try {\n                        await promise;\n                    }\n                    catch { }\n                });\n            }\n            try {\n                await Promise.all(promises);\n            }\n            catch (error) {\n                this._beforeError(error);\n                return;\n            }\n        }\n        // The above is running a promise, therefore we need to check if this request has been aborted yet again.\n        if (this.isAborted) {\n            return;\n        }\n        if (response.headers.location && redirectCodes.has(statusCode)) {\n            // We're being redirected, we don't care about the response.\n            // It'd be best to abort the request, but we can't because\n            // we would have to sacrifice the TCP connection. We don't want that.\n            const shouldFollow = typeof options.followRedirect === 'function' ? options.followRedirect(typedResponse) : options.followRedirect;\n            if (shouldFollow) {\n                response.resume();\n                this._cancelTimeouts();\n                this._unproxyEvents();\n                if (this.redirectUrls.length >= options.maxRedirects) {\n                    this._beforeError(new MaxRedirectsError(this));\n                    return;\n                }\n                this._request = undefined;\n                const updatedOptions = new Options(undefined, undefined, this.options);\n                const serverRequestedGet = statusCode === 303 && updatedOptions.method !== 'GET' && updatedOptions.method !== 'HEAD';\n                const canRewrite = statusCode !== 307 && statusCode !== 308;\n                const userRequestedGet = updatedOptions.methodRewriting && canRewrite;\n                if (serverRequestedGet || userRequestedGet) {\n                    updatedOptions.method = 'GET';\n                    updatedOptions.body = undefined;\n                    updatedOptions.json = undefined;\n                    updatedOptions.form = undefined;\n                    delete updatedOptions.headers['content-length'];\n                }\n                try {\n                    // We need this in order to support UTF-8\n                    const redirectBuffer = Buffer.from(response.headers.location, 'binary').toString();\n                    const redirectUrl = new URL(redirectBuffer, url);\n                    if (!isUnixSocketURL(url) && isUnixSocketURL(redirectUrl)) {\n                        this._beforeError(new RequestError('Cannot redirect to UNIX socket', {}, this));\n                        return;\n                    }\n                    // Redirecting to a different site, clear sensitive data.\n                    if (redirectUrl.hostname !== url.hostname || redirectUrl.port !== url.port) {\n                        if ('host' in updatedOptions.headers) {\n                            delete updatedOptions.headers.host;\n                        }\n                        if ('cookie' in updatedOptions.headers) {\n                            delete updatedOptions.headers.cookie;\n                        }\n                        if ('authorization' in updatedOptions.headers) {\n                            delete updatedOptions.headers.authorization;\n                        }\n                        if (updatedOptions.username || updatedOptions.password) {\n                            updatedOptions.username = '';\n                            updatedOptions.password = '';\n                        }\n                    }\n                    else {\n                        redirectUrl.username = updatedOptions.username;\n                        redirectUrl.password = updatedOptions.password;\n                    }\n                    this.redirectUrls.push(redirectUrl);\n                    updatedOptions.prefixUrl = '';\n                    updatedOptions.url = redirectUrl;\n                    for (const hook of updatedOptions.hooks.beforeRedirect) {\n                        // eslint-disable-next-line no-await-in-loop\n                        await hook(updatedOptions, typedResponse);\n                    }\n                    this.emit('redirect', updatedOptions, typedResponse);\n                    this.options = updatedOptions;\n                    await this._makeRequest();\n                }\n                catch (error) {\n                    this._beforeError(error);\n                    return;\n                }\n                return;\n            }\n        }\n        // `HTTPError`s always have `error.response.body` defined.\n        // Therefore, we cannot retry if `options.throwHttpErrors` is false.\n        // On the last retry, if `options.throwHttpErrors` is false, we would need to return the body,\n        // but that wouldn't be possible since the body would be already read in `error.response.body`.\n        if (options.isStream && options.throwHttpErrors && !isResponseOk(typedResponse)) {\n            this._beforeError(new HTTPError(typedResponse));\n            return;\n        }\n        response.on('readable', () => {\n            if (this._triggerRead) {\n                this._read();\n            }\n        });\n        this.on('resume', () => {\n            response.resume();\n        });\n        this.on('pause', () => {\n            response.pause();\n        });\n        response.once('end', () => {\n            this.push(null);\n        });\n        if (this._noPipe) {\n            const success = await this._setRawBody();\n            if (success) {\n                this.emit('response', response);\n            }\n            return;\n        }\n        this.emit('response', response);\n        for (const destination of this._pipedServerResponses) {\n            if (destination.headersSent) {\n                continue;\n            }\n            // eslint-disable-next-line guard-for-in\n            for (const key in response.headers) {\n                const isAllowed = options.decompress ? key !== 'content-encoding' : true;\n                const value = response.headers[key];\n                if (isAllowed) {\n                    destination.setHeader(key, value);\n                }\n            }\n            destination.statusCode = statusCode;\n        }\n    }\n    async _setRawBody(from = this) {\n        if (from.readableEnded) {\n            return false;\n        }\n        try {\n            // Errors are emitted via the `error` event\n            const fromArray = await from.toArray();\n            const rawBody = isBuffer(fromArray.at(0)) ? Buffer.concat(fromArray) : Buffer.from(fromArray.join(''));\n            // On retry Request is destroyed with no error, therefore the above will successfully resolve.\n            // So in order to check if this was really successfull, we need to check if it has been properly ended.\n            if (!this.isAborted) {\n                this.response.rawBody = rawBody;\n                return true;\n            }\n        }\n        catch { }\n        return false;\n    }\n    async _onResponse(response) {\n        try {\n            await this._onResponseBase(response);\n        }\n        catch (error) {\n            /* istanbul ignore next: better safe than sorry */\n            this._beforeError(error);\n        }\n    }\n    _onRequest(request) {\n        const { options } = this;\n        const { timeout, url } = options;\n        timer(request);\n        if (this.options.http2) {\n            // Unset stream timeout, as the `timeout` option was used only for connection timeout.\n            request.setTimeout(0);\n        }\n        this._cancelTimeouts = timedOut(request, timeout, url);\n        const responseEventName = options.cache ? 'cacheableResponse' : 'response';\n        request.once(responseEventName, (response) => {\n            void this._onResponse(response);\n        });\n        request.once('error', (error) => {\n            this._aborted = true;\n            // Force clean-up, because some packages (e.g. nock) don't do this.\n            request.destroy();\n            error = error instanceof TimedOutTimeoutError ? new TimeoutError(error, this.timings, this) : new RequestError(error.message, error, this);\n            this._beforeError(error);\n        });\n        this._unproxyEvents = proxyEvents(request, this, proxiedRequestEvents);\n        this._request = request;\n        this.emit('uploadProgress', this.uploadProgress);\n        this._sendBody();\n        this.emit('request', request);\n    }\n    async _asyncWrite(chunk) {\n        return new Promise((resolve, reject) => {\n            super.write(chunk, error => {\n                if (error) {\n                    reject(error);\n                    return;\n                }\n                resolve();\n            });\n        });\n    }\n    _sendBody() {\n        // Send body\n        const { body } = this.options;\n        const currentRequest = this.redirectUrls.length === 0 ? this : this._request ?? this;\n        if (is.nodeStream(body)) {\n            body.pipe(currentRequest);\n        }\n        else if (is.generator(body) || is.asyncGenerator(body)) {\n            (async () => {\n                try {\n                    for await (const chunk of body) {\n                        await this._asyncWrite(chunk);\n                    }\n                    super.end();\n                }\n                catch (error) {\n                    this._beforeError(error);\n                }\n            })();\n        }\n        else if (!is.undefined(body)) {\n            this._writeRequest(body, undefined, () => { });\n            currentRequest.end();\n        }\n        else if (this._cannotHaveBody || this._noPipe) {\n            currentRequest.end();\n        }\n    }\n    _prepareCache(cache) {\n        if (!cacheableStore.has(cache)) {\n            const cacheableRequest = new CacheableRequest(((requestOptions, handler) => {\n                const result = requestOptions._request(requestOptions, handler);\n                // TODO: remove this when `cacheable-request` supports async request functions.\n                if (is.promise(result)) {\n                    // We only need to implement the error handler in order to support HTTP2 caching.\n                    // The result will be a promise anyway.\n                    // @ts-expect-error ignore\n                    result.once = (event, handler) => {\n                        if (event === 'error') {\n                            (async () => {\n                                try {\n                                    await result;\n                                }\n                                catch (error) {\n                                    handler(error);\n                                }\n                            })();\n                        }\n                        else if (event === 'abort' || event === 'destroy') {\n                            // The empty catch is needed here in case when\n                            // it rejects before it's `await`ed in `_makeRequest`.\n                            (async () => {\n                                try {\n                                    const request = (await result);\n                                    request.once(event, handler);\n                                }\n                                catch { }\n                            })();\n                        }\n                        else {\n                            /* istanbul ignore next: safety check */\n                            throw new Error(`Unknown HTTP2 promise event: ${event}`);\n                        }\n                        return result;\n                    };\n                }\n                return result;\n            }), cache);\n            cacheableStore.set(cache, cacheableRequest.request());\n        }\n    }\n    async _createCacheableRequest(url, options) {\n        return new Promise((resolve, reject) => {\n            // TODO: Remove `utils/url-to-options.ts` when `cacheable-request` is fixed\n            Object.assign(options, urlToOptions(url));\n            let request;\n            // TODO: Fix `cacheable-response`. This is ugly.\n            const cacheRequest = cacheableStore.get(options.cache)(options, async (response) => {\n                response._readableState.autoDestroy = false;\n                if (request) {\n                    const fix = () => {\n                        if (response.req) {\n                            response.complete = response.req.res.complete;\n                        }\n                    };\n                    response.prependOnceListener('end', fix);\n                    fix();\n                    (await request).emit('cacheableResponse', response);\n                }\n                resolve(response);\n            });\n            cacheRequest.once('error', reject);\n            cacheRequest.once('request', async (requestOrPromise) => {\n                request = requestOrPromise;\n                resolve(request);\n            });\n        });\n    }\n    async _makeRequest() {\n        const { options } = this;\n        const { headers, username, password } = options;\n        const cookieJar = options.cookieJar;\n        for (const key in headers) {\n            if (is.undefined(headers[key])) {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete headers[key];\n            }\n            else if (is.null(headers[key])) {\n                throw new TypeError(`Use \\`undefined\\` instead of \\`null\\` to delete the \\`${key}\\` header`);\n            }\n        }\n        if (options.decompress && is.undefined(headers['accept-encoding'])) {\n            headers['accept-encoding'] = supportsBrotli ? 'gzip, deflate, br' : 'gzip, deflate';\n        }\n        if (username || password) {\n            const credentials = Buffer.from(`${username}:${password}`).toString('base64');\n            headers.authorization = `Basic ${credentials}`;\n        }\n        // Set cookies\n        if (cookieJar) {\n            const cookieString = await cookieJar.getCookieString(options.url.toString());\n            if (is.nonEmptyString(cookieString)) {\n                headers.cookie = cookieString;\n            }\n        }\n        // Reset `prefixUrl`\n        options.prefixUrl = '';\n        let request;\n        for (const hook of options.hooks.beforeRequest) {\n            // eslint-disable-next-line no-await-in-loop\n            const result = await hook(options);\n            if (!is.undefined(result)) {\n                // @ts-expect-error Skip the type mismatch to support abstract responses\n                request = () => result;\n                break;\n            }\n        }\n        request ||= options.getRequestFunction();\n        const url = options.url;\n        this._requestOptions = options.createNativeRequestOptions();\n        if (options.cache) {\n            this._requestOptions._request = request;\n            this._requestOptions.cache = options.cache;\n            this._requestOptions.body = options.body;\n            this._prepareCache(options.cache);\n        }\n        // Cache support\n        const function_ = options.cache ? this._createCacheableRequest : request;\n        try {\n            // We can't do `await fn(...)`,\n            // because stream `error` event can be emitted before `Promise.resolve()`.\n            let requestOrResponse = function_(url, this._requestOptions);\n            if (is.promise(requestOrResponse)) {\n                requestOrResponse = await requestOrResponse;\n            }\n            // Fallback\n            if (is.undefined(requestOrResponse)) {\n                requestOrResponse = options.getFallbackRequestFunction()(url, this._requestOptions);\n                if (is.promise(requestOrResponse)) {\n                    requestOrResponse = await requestOrResponse;\n                }\n            }\n            if (isClientRequest(requestOrResponse)) {\n                this._onRequest(requestOrResponse);\n            }\n            else if (this.writable) {\n                this.once('finish', () => {\n                    void this._onResponse(requestOrResponse);\n                });\n                this._sendBody();\n            }\n            else {\n                void this._onResponse(requestOrResponse);\n            }\n        }\n        catch (error) {\n            if (error instanceof CacheableCacheError) {\n                throw new CacheError(error, this);\n            }\n            throw error;\n        }\n    }\n    async _error(error) {\n        try {\n            if (error instanceof HTTPError && !this.options.throwHttpErrors) {\n                // This branch can be reached only when using the Promise API\n                // Skip calling the hooks on purpose.\n                // See https://github.com/sindresorhus/got/issues/2103\n            }\n            else {\n                for (const hook of this.options.hooks.beforeError) {\n                    // eslint-disable-next-line no-await-in-loop\n                    error = await hook(error);\n                }\n            }\n        }\n        catch (error_) {\n            error = new RequestError(error_.message, error_, this);\n        }\n        this.destroy(error);\n    }\n    _writeRequest(chunk, encoding, callback) {\n        if (!this._request || this._request.destroyed) {\n            // Probably the `ClientRequest` instance will throw\n            return;\n        }\n        this._request.write(chunk, encoding, (error) => {\n            // The `!destroyed` check is required to prevent `uploadProgress` being emitted after the stream was destroyed\n            if (!error && !this._request.destroyed) {\n                this._uploadedSize += Buffer.byteLength(chunk, encoding);\n                const progress = this.uploadProgress;\n                if (progress.percent < 1) {\n                    this.emit('uploadProgress', progress);\n                }\n            }\n            callback(error);\n        });\n    }\n    /**\n    The remote IP address.\n    */\n    get ip() {\n        return this.socket?.remoteAddress;\n    }\n    /**\n    Indicates whether the request has been aborted or not.\n    */\n    get isAborted() {\n        return this._aborted;\n    }\n    get socket() {\n        return this._request?.socket ?? undefined;\n    }\n    /**\n    Progress event for downloading (receiving a response).\n    */\n    get downloadProgress() {\n        let percent;\n        if (this._responseSize) {\n            percent = this._downloadedSize / this._responseSize;\n        }\n        else if (this._responseSize === this._downloadedSize) {\n            percent = 1;\n        }\n        else {\n            percent = 0;\n        }\n        return {\n            percent,\n            transferred: this._downloadedSize,\n            total: this._responseSize,\n        };\n    }\n    /**\n    Progress event for uploading (sending a request).\n    */\n    get uploadProgress() {\n        let percent;\n        if (this._bodySize) {\n            percent = this._uploadedSize / this._bodySize;\n        }\n        else if (this._bodySize === this._uploadedSize) {\n            percent = 1;\n        }\n        else {\n            percent = 0;\n        }\n        return {\n            percent,\n            transferred: this._uploadedSize,\n            total: this._bodySize,\n        };\n    }\n    /**\n    The object contains the following properties:\n\n    - `start` - Time when the request started.\n    - `socket` - Time when a socket was assigned to the request.\n    - `lookup` - Time when the DNS lookup finished.\n    - `connect` - Time when the socket successfully connected.\n    - `secureConnect` - Time when the socket securely connected.\n    - `upload` - Time when the request finished uploading.\n    - `response` - Time when the request fired `response` event.\n    - `end` - Time when the response fired `end` event.\n    - `error` - Time when the request fired `error` event.\n    - `abort` - Time when the request fired `abort` event.\n    - `phases`\n        - `wait` - `timings.socket - timings.start`\n        - `dns` - `timings.lookup - timings.socket`\n        - `tcp` - `timings.connect - timings.lookup`\n        - `tls` - `timings.secureConnect - timings.connect`\n        - `request` - `timings.upload - (timings.secureConnect || timings.connect)`\n        - `firstByte` - `timings.response - timings.upload`\n        - `download` - `timings.end - timings.response`\n        - `total` - `(timings.end || timings.error || timings.abort) - timings.start`\n\n    If something has not been measured yet, it will be `undefined`.\n\n    __Note__: The time is a `number` representing the milliseconds elapsed since the UNIX epoch.\n    */\n    get timings() {\n        return this._request?.timings;\n    }\n    /**\n    Whether the response was retrieved from the cache.\n    */\n    get isFromCache() {\n        return this._isFromCache;\n    }\n    get reusedSocket() {\n        return this._request?.reusedSocket;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}