{"ast":null,"code":"import { EventEmitter } from 'node:events';\nimport is from '@sindresorhus/is';\nimport PCancelable from 'p-cancelable';\nimport { HTTPError, RetryError } from '../core/errors.js';\nimport Request from '../core/index.js';\nimport { parseBody, isResponseOk, ParseError } from '../core/response.js';\nimport proxyEvents from '../core/utils/proxy-events.js';\nimport { CancelError } from './types.js';\nconst proxiedRequestEvents = ['request', 'response', 'redirect', 'uploadProgress', 'downloadProgress'];\nexport default function asPromise(firstRequest) {\n  let globalRequest;\n  let globalResponse;\n  let normalizedOptions;\n  const emitter = new EventEmitter();\n  const promise = new PCancelable((resolve, reject, onCancel) => {\n    onCancel(() => {\n      globalRequest.destroy();\n    });\n    onCancel.shouldReject = false;\n    onCancel(() => {\n      reject(new CancelError(globalRequest));\n    });\n    const makeRequest = retryCount => {\n      var _request$options;\n      // Errors when a new request is made after the promise settles.\n      // Used to detect a race condition.\n      // See https://github.com/sindresorhus/got/issues/1489\n      onCancel(() => {});\n      const request = firstRequest !== null && firstRequest !== void 0 ? firstRequest : new Request(undefined, undefined, normalizedOptions);\n      request.retryCount = retryCount;\n      request._noPipe = true;\n      globalRequest = request;\n      request.once('response', async response => {\n        var _response$headers$con;\n        // Parse body\n        const contentEncoding = ((_response$headers$con = response.headers['content-encoding']) !== null && _response$headers$con !== void 0 ? _response$headers$con : '').toLowerCase();\n        const isCompressed = contentEncoding === 'gzip' || contentEncoding === 'deflate' || contentEncoding === 'br';\n        const {\n          options\n        } = request;\n        if (isCompressed && !options.decompress) {\n          response.body = response.rawBody;\n        } else {\n          try {\n            response.body = parseBody(response, options.responseType, options.parseJson, options.encoding);\n          } catch (error) {\n            // Fall back to `utf8`\n            try {\n              response.body = response.rawBody.toString();\n            } catch (error) {\n              request._beforeError(new ParseError(error, response));\n              return;\n            }\n            if (isResponseOk(response)) {\n              request._beforeError(error);\n              return;\n            }\n          }\n        }\n        try {\n          const hooks = options.hooks.afterResponse;\n          for (const [index, hook] of hooks.entries()) {\n            // @ts-expect-error TS doesn't notice that CancelableRequest is a Promise\n            // eslint-disable-next-line no-await-in-loop\n            response = await hook(response, async updatedOptions => {\n              options.merge(updatedOptions);\n              options.prefixUrl = '';\n              if (updatedOptions.url) {\n                options.url = updatedOptions.url;\n              }\n              // Remove any further hooks for that request, because we'll call them anyway.\n              // The loop continues. We don't want duplicates (asPromise recursion).\n              options.hooks.afterResponse = options.hooks.afterResponse.slice(0, index);\n              throw new RetryError(request);\n            });\n            if (!(is.object(response) && is.number(response.statusCode) && !is.nullOrUndefined(response.body))) {\n              throw new TypeError('The `afterResponse` hook returned an invalid value');\n            }\n          }\n        } catch (error) {\n          request._beforeError(error);\n          return;\n        }\n        globalResponse = response;\n        if (!isResponseOk(response)) {\n          request._beforeError(new HTTPError(response));\n          return;\n        }\n        request.destroy();\n        resolve(request.options.resolveBodyOnly ? response.body : response);\n      });\n      const onError = error => {\n        if (promise.isCanceled) {\n          return;\n        }\n        const {\n          options\n        } = request;\n        if (error instanceof HTTPError && !options.throwHttpErrors) {\n          const {\n            response\n          } = error;\n          request.destroy();\n          resolve(request.options.resolveBodyOnly ? response.body : response);\n          return;\n        }\n        reject(error);\n      };\n      request.once('error', onError);\n      const previousBody = (_request$options = request.options) === null || _request$options === void 0 ? void 0 : _request$options.body;\n      request.once('retry', (newRetryCount, error) => {\n        firstRequest = undefined;\n        const newBody = request.options.body;\n        if (previousBody === newBody && is.nodeStream(newBody)) {\n          error.message = 'Cannot retry with consumed body stream';\n          onError(error);\n          return;\n        }\n        // This is needed! We need to reuse `request.options` because they can get modified!\n        // For example, by calling `promise.json()`.\n        normalizedOptions = request.options;\n        makeRequest(newRetryCount);\n      });\n      proxyEvents(request, emitter, proxiedRequestEvents);\n      if (is.undefined(firstRequest)) {\n        void request.flush();\n      }\n    };\n    makeRequest(0);\n  });\n  promise.on = (event, function_) => {\n    emitter.on(event, function_);\n    return promise;\n  };\n  promise.off = (event, function_) => {\n    emitter.off(event, function_);\n    return promise;\n  };\n  const shortcut = responseType => {\n    const newPromise = (async () => {\n      // Wait until downloading has ended\n      await promise;\n      const {\n        options\n      } = globalResponse.request;\n      return parseBody(globalResponse, responseType, options.parseJson, options.encoding);\n    })();\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));\n    return newPromise;\n  };\n  promise.json = () => {\n    if (globalRequest.options) {\n      const {\n        headers\n      } = globalRequest.options;\n      if (!globalRequest.writableFinished && !('accept' in headers)) {\n        headers.accept = 'application/json';\n      }\n    }\n    return shortcut('json');\n  };\n  promise.buffer = () => shortcut('buffer');\n  promise.text = () => shortcut('text');\n  return promise;\n}","map":{"version":3,"names":["EventEmitter","is","PCancelable","HTTPError","RetryError","Request","parseBody","isResponseOk","ParseError","proxyEvents","CancelError","proxiedRequestEvents","asPromise","firstRequest","globalRequest","globalResponse","normalizedOptions","emitter","promise","resolve","reject","onCancel","destroy","shouldReject","makeRequest","retryCount","_request$options","request","undefined","_noPipe","once","response","_response$headers$con","contentEncoding","headers","toLowerCase","isCompressed","options","decompress","body","rawBody","responseType","parseJson","encoding","error","toString","_beforeError","hooks","afterResponse","index","hook","entries","updatedOptions","merge","prefixUrl","url","slice","object","number","statusCode","nullOrUndefined","TypeError","resolveBodyOnly","onError","isCanceled","throwHttpErrors","previousBody","newRetryCount","newBody","nodeStream","message","flush","on","event","function_","off","shortcut","newPromise","Object","defineProperties","getOwnPropertyDescriptors","json","writableFinished","accept","buffer","text"],"sources":["C:/Users/sakas/OneDrive/Desktop/gogo/node_modules/got/dist/source/as-promise/index.js"],"sourcesContent":["import { EventEmitter } from 'node:events';\nimport is from '@sindresorhus/is';\nimport PCancelable from 'p-cancelable';\nimport { HTTPError, RetryError, } from '../core/errors.js';\nimport Request from '../core/index.js';\nimport { parseBody, isResponseOk, ParseError, } from '../core/response.js';\nimport proxyEvents from '../core/utils/proxy-events.js';\nimport { CancelError } from './types.js';\nconst proxiedRequestEvents = [\n    'request',\n    'response',\n    'redirect',\n    'uploadProgress',\n    'downloadProgress',\n];\nexport default function asPromise(firstRequest) {\n    let globalRequest;\n    let globalResponse;\n    let normalizedOptions;\n    const emitter = new EventEmitter();\n    const promise = new PCancelable((resolve, reject, onCancel) => {\n        onCancel(() => {\n            globalRequest.destroy();\n        });\n        onCancel.shouldReject = false;\n        onCancel(() => {\n            reject(new CancelError(globalRequest));\n        });\n        const makeRequest = (retryCount) => {\n            // Errors when a new request is made after the promise settles.\n            // Used to detect a race condition.\n            // See https://github.com/sindresorhus/got/issues/1489\n            onCancel(() => { });\n            const request = firstRequest ?? new Request(undefined, undefined, normalizedOptions);\n            request.retryCount = retryCount;\n            request._noPipe = true;\n            globalRequest = request;\n            request.once('response', async (response) => {\n                // Parse body\n                const contentEncoding = (response.headers['content-encoding'] ?? '').toLowerCase();\n                const isCompressed = contentEncoding === 'gzip' || contentEncoding === 'deflate' || contentEncoding === 'br';\n                const { options } = request;\n                if (isCompressed && !options.decompress) {\n                    response.body = response.rawBody;\n                }\n                else {\n                    try {\n                        response.body = parseBody(response, options.responseType, options.parseJson, options.encoding);\n                    }\n                    catch (error) {\n                        // Fall back to `utf8`\n                        try {\n                            response.body = response.rawBody.toString();\n                        }\n                        catch (error) {\n                            request._beforeError(new ParseError(error, response));\n                            return;\n                        }\n                        if (isResponseOk(response)) {\n                            request._beforeError(error);\n                            return;\n                        }\n                    }\n                }\n                try {\n                    const hooks = options.hooks.afterResponse;\n                    for (const [index, hook] of hooks.entries()) {\n                        // @ts-expect-error TS doesn't notice that CancelableRequest is a Promise\n                        // eslint-disable-next-line no-await-in-loop\n                        response = await hook(response, async (updatedOptions) => {\n                            options.merge(updatedOptions);\n                            options.prefixUrl = '';\n                            if (updatedOptions.url) {\n                                options.url = updatedOptions.url;\n                            }\n                            // Remove any further hooks for that request, because we'll call them anyway.\n                            // The loop continues. We don't want duplicates (asPromise recursion).\n                            options.hooks.afterResponse = options.hooks.afterResponse.slice(0, index);\n                            throw new RetryError(request);\n                        });\n                        if (!(is.object(response) && is.number(response.statusCode) && !is.nullOrUndefined(response.body))) {\n                            throw new TypeError('The `afterResponse` hook returned an invalid value');\n                        }\n                    }\n                }\n                catch (error) {\n                    request._beforeError(error);\n                    return;\n                }\n                globalResponse = response;\n                if (!isResponseOk(response)) {\n                    request._beforeError(new HTTPError(response));\n                    return;\n                }\n                request.destroy();\n                resolve(request.options.resolveBodyOnly ? response.body : response);\n            });\n            const onError = (error) => {\n                if (promise.isCanceled) {\n                    return;\n                }\n                const { options } = request;\n                if (error instanceof HTTPError && !options.throwHttpErrors) {\n                    const { response } = error;\n                    request.destroy();\n                    resolve(request.options.resolveBodyOnly ? response.body : response);\n                    return;\n                }\n                reject(error);\n            };\n            request.once('error', onError);\n            const previousBody = request.options?.body;\n            request.once('retry', (newRetryCount, error) => {\n                firstRequest = undefined;\n                const newBody = request.options.body;\n                if (previousBody === newBody && is.nodeStream(newBody)) {\n                    error.message = 'Cannot retry with consumed body stream';\n                    onError(error);\n                    return;\n                }\n                // This is needed! We need to reuse `request.options` because they can get modified!\n                // For example, by calling `promise.json()`.\n                normalizedOptions = request.options;\n                makeRequest(newRetryCount);\n            });\n            proxyEvents(request, emitter, proxiedRequestEvents);\n            if (is.undefined(firstRequest)) {\n                void request.flush();\n            }\n        };\n        makeRequest(0);\n    });\n    promise.on = (event, function_) => {\n        emitter.on(event, function_);\n        return promise;\n    };\n    promise.off = (event, function_) => {\n        emitter.off(event, function_);\n        return promise;\n    };\n    const shortcut = (responseType) => {\n        const newPromise = (async () => {\n            // Wait until downloading has ended\n            await promise;\n            const { options } = globalResponse.request;\n            return parseBody(globalResponse, responseType, options.parseJson, options.encoding);\n        })();\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));\n        return newPromise;\n    };\n    promise.json = () => {\n        if (globalRequest.options) {\n            const { headers } = globalRequest.options;\n            if (!globalRequest.writableFinished && !('accept' in headers)) {\n                headers.accept = 'application/json';\n            }\n        }\n        return shortcut('json');\n    };\n    promise.buffer = () => shortcut('buffer');\n    promise.text = () => shortcut('text');\n    return promise;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}