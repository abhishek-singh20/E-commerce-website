{"ast":null,"code":"import _objectSpread from \"C:/Users/sakas/OneDrive/Desktop/gogo/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport EventEmitter from 'node:events';\nimport urlLib from 'node:url';\nimport crypto from 'node:crypto';\nimport stream, { PassThrough as PassThroughStream } from 'node:stream';\nimport normalizeUrl from 'normalize-url';\nimport { getStreamAsBuffer } from 'get-stream';\nimport CachePolicy from 'http-cache-semantics';\nimport Response from 'responselike';\nimport Keyv from 'keyv';\nimport mimicResponse from 'mimic-response';\nimport { CacheError, RequestError } from './types.js';\nclass CacheableRequest {\n  constructor(cacheRequest, cacheAdapter) {\n    var _this = this;\n    this.hooks = new Map();\n    this.request = () => (options, callback) => {\n      let url;\n      if (typeof options === 'string') {\n        url = normalizeUrlObject(urlLib.parse(options));\n        options = {};\n      } else if (options instanceof urlLib.URL) {\n        url = normalizeUrlObject(urlLib.parse(options.toString()));\n        options = {};\n      } else {\n        var _options$path;\n        const [pathname, ...searchParts] = ((_options$path = options.path) !== null && _options$path !== void 0 ? _options$path : '').split('?');\n        const search = searchParts.length > 0 ? \"?\".concat(searchParts.join('?')) : '';\n        url = normalizeUrlObject(_objectSpread(_objectSpread({}, options), {}, {\n          pathname,\n          search\n        }));\n      }\n      options = _objectSpread(_objectSpread({\n        headers: {},\n        method: 'GET',\n        cache: true,\n        strictTtl: false,\n        automaticFailover: false\n      }, options), urlObjectToRequestOptions(url));\n      options.headers = Object.fromEntries(entries(options.headers).map(_ref => {\n        let [key, value] = _ref;\n        return [key.toLowerCase(), value];\n      }));\n      const ee = new EventEmitter();\n      const normalizedUrlString = normalizeUrl(urlLib.format(url), {\n        stripWWW: false,\n        // eslint-disable-line @typescript-eslint/naming-convention\n        removeTrailingSlash: false,\n        stripAuthentication: false\n      });\n      let key = \"\".concat(options.method, \":\").concat(normalizedUrlString);\n      // POST, PATCH, and PUT requests may be cached, depending on the response\n      // cache-control headers. As a result, the body of the request should be\n      // added to the cache key in order to avoid collisions.\n      if (options.body && options.method !== undefined && ['POST', 'PATCH', 'PUT'].includes(options.method)) {\n        if (options.body instanceof stream.Readable) {\n          // Streamed bodies should completely skip the cache because they may\n          // or may not be hashable and in either case the stream would need to\n          // close before the cache key could be generated.\n          options.cache = false;\n        } else {\n          key += \":\".concat(crypto.createHash('md5').update(options.body).digest('hex'));\n        }\n      }\n      let revalidate = false;\n      let madeRequest = false;\n      const makeRequest = options_ => {\n        madeRequest = true;\n        let requestErrored = false;\n        let requestErrorCallback = () => {};\n        const requestErrorPromise = new Promise(resolve => {\n          requestErrorCallback = () => {\n            if (!requestErrored) {\n              requestErrored = true;\n              resolve();\n            }\n          };\n        });\n        const handler = async response => {\n          if (revalidate) {\n            response.status = response.statusCode;\n            const revalidatedPolicy = CachePolicy.fromObject(revalidate.cachePolicy).revalidatedPolicy(options_, response);\n            if (!revalidatedPolicy.modified) {\n              response.resume();\n              await new Promise(resolve => {\n                // Skipping 'error' handler cause 'error' event should't be emitted for 304 response\n                response.once('end', resolve);\n              });\n              const headers = convertHeaders(revalidatedPolicy.policy.responseHeaders());\n              response = new Response({\n                statusCode: revalidate.statusCode,\n                headers,\n                body: revalidate.body,\n                url: revalidate.url\n              });\n              response.cachePolicy = revalidatedPolicy.policy;\n              response.fromCache = true;\n            }\n          }\n          if (!response.fromCache) {\n            response.cachePolicy = new CachePolicy(options_, response, options_);\n            response.fromCache = false;\n          }\n          let clonedResponse;\n          if (options_.cache && response.cachePolicy.storable()) {\n            clonedResponse = cloneResponse(response);\n            (async () => {\n              try {\n                const bodyPromise = getStreamAsBuffer(response);\n                await Promise.race([requestErrorPromise, new Promise(resolve => response.once('end', resolve)),\n                // eslint-disable-line no-promise-executor-return\n                new Promise(resolve => response.once('close', resolve)) // eslint-disable-line no-promise-executor-return\n                ]);\n                const body = await bodyPromise;\n                let value = {\n                  url: response.url,\n                  statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,\n                  body,\n                  cachePolicy: response.cachePolicy.toObject()\n                };\n                let ttl = options_.strictTtl ? response.cachePolicy.timeToLive() : undefined;\n                if (options_.maxTtl) {\n                  ttl = ttl ? Math.min(ttl, options_.maxTtl) : options_.maxTtl;\n                }\n                if (this.hooks.size > 0) {\n                  /* eslint-disable no-await-in-loop */\n                  for (const key_ of this.hooks.keys()) {\n                    value = await this.runHook(key_, value, response);\n                  }\n                  /* eslint-enable no-await-in-loop */\n                }\n                await this.cache.set(key, value, ttl);\n              } catch (error) {\n                ee.emit('error', new CacheError(error));\n              }\n            })();\n          } else if (options_.cache && revalidate) {\n            (async () => {\n              try {\n                await this.cache.delete(key);\n              } catch (error) {\n                ee.emit('error', new CacheError(error));\n              }\n            })();\n          }\n          ee.emit('response', clonedResponse !== null && clonedResponse !== void 0 ? clonedResponse : response);\n          if (typeof callback === 'function') {\n            callback(clonedResponse !== null && clonedResponse !== void 0 ? clonedResponse : response);\n          }\n        };\n        try {\n          const request_ = this.cacheRequest(options_, handler);\n          request_.once('error', requestErrorCallback);\n          request_.once('abort', requestErrorCallback);\n          request_.once('destroy', requestErrorCallback);\n          ee.emit('request', request_);\n        } catch (error) {\n          ee.emit('error', new RequestError(error));\n        }\n      };\n      (async () => {\n        const get = async options_ => {\n          await Promise.resolve();\n          const cacheEntry = options_.cache ? await this.cache.get(key) : undefined;\n          if (cacheEntry === undefined && !options_.forceRefresh) {\n            makeRequest(options_);\n            return;\n          }\n          const policy = CachePolicy.fromObject(cacheEntry.cachePolicy);\n          if (policy.satisfiesWithoutRevalidation(options_) && !options_.forceRefresh) {\n            const headers = convertHeaders(policy.responseHeaders());\n            const response = new Response({\n              statusCode: cacheEntry.statusCode,\n              headers,\n              body: cacheEntry.body,\n              url: cacheEntry.url\n            });\n            response.cachePolicy = policy;\n            response.fromCache = true;\n            ee.emit('response', response);\n            if (typeof callback === 'function') {\n              callback(response);\n            }\n          } else if (policy.satisfiesWithoutRevalidation(options_) && Date.now() >= policy.timeToLive() && options_.forceRefresh) {\n            await this.cache.delete(key);\n            options_.headers = policy.revalidationHeaders(options_);\n            makeRequest(options_);\n          } else {\n            revalidate = cacheEntry;\n            options_.headers = policy.revalidationHeaders(options_);\n            makeRequest(options_);\n          }\n        };\n        const errorHandler = error => ee.emit('error', new CacheError(error));\n        if (this.cache instanceof Keyv) {\n          const cachek = this.cache;\n          cachek.once('error', errorHandler);\n          ee.on('error', () => cachek.removeListener('error', errorHandler));\n          ee.on('response', () => cachek.removeListener('error', errorHandler));\n        }\n        try {\n          await get(options);\n        } catch (error) {\n          if (options.automaticFailover && !madeRequest) {\n            makeRequest(options);\n          }\n          ee.emit('error', new CacheError(error));\n        }\n      })();\n      return ee;\n    };\n    this.addHook = (name, function_) => {\n      if (!this.hooks.has(name)) {\n        this.hooks.set(name, function_);\n      }\n    };\n    this.removeHook = name => this.hooks.delete(name);\n    this.getHook = name => this.hooks.get(name);\n    this.runHook = async function (name) {\n      var _this$hooks$get;\n      for (var _len = arguments.length, arguments_ = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        arguments_[_key - 1] = arguments[_key];\n      }\n      return (_this$hooks$get = _this.hooks.get(name)) === null || _this$hooks$get === void 0 ? void 0 : _this$hooks$get(...arguments_);\n    };\n    if (cacheAdapter instanceof Keyv) {\n      this.cache = cacheAdapter;\n    } else if (typeof cacheAdapter === 'string') {\n      this.cache = new Keyv({\n        uri: cacheAdapter,\n        namespace: 'cacheable-request'\n      });\n    } else {\n      this.cache = new Keyv({\n        store: cacheAdapter,\n        namespace: 'cacheable-request'\n      });\n    }\n    this.request = this.request.bind(this);\n    this.cacheRequest = cacheRequest;\n  }\n}\nconst entries = Object.entries;\nconst cloneResponse = response => {\n  const clone = new PassThroughStream({\n    autoDestroy: false\n  });\n  mimicResponse(response, clone);\n  return response.pipe(clone);\n};\nconst urlObjectToRequestOptions = url => {\n  const options = _objectSpread({}, url);\n  options.path = \"\".concat(url.pathname || '/').concat(url.search || '');\n  delete options.pathname;\n  delete options.search;\n  return options;\n};\nconst normalizeUrlObject = url => (\n// If url was parsed by url.parse or new URL:\n// - hostname will be set\n// - host will be hostname[:port]\n// - port will be set if it was explicit in the parsed string\n// Otherwise, url was from request options:\n// - hostname or host may be set\n// - host shall not have port encoded\n{\n  protocol: url.protocol,\n  auth: url.auth,\n  hostname: url.hostname || url.host || 'localhost',\n  port: url.port,\n  pathname: url.pathname,\n  search: url.search\n});\nconst convertHeaders = headers => {\n  const result = [];\n  for (const name of Object.keys(headers)) {\n    result[name.toLowerCase()] = headers[name];\n  }\n  return result;\n};\nexport default CacheableRequest;\nexport * from './types.js';\nexport const onResponse = 'onResponse';","map":{"version":3,"names":["EventEmitter","urlLib","crypto","stream","PassThrough","PassThroughStream","normalizeUrl","getStreamAsBuffer","CachePolicy","Response","Keyv","mimicResponse","CacheError","RequestError","CacheableRequest","constructor","cacheRequest","cacheAdapter","_this","hooks","Map","request","options","callback","url","normalizeUrlObject","parse","URL","toString","_options$path","pathname","searchParts","path","split","search","length","concat","join","_objectSpread","headers","method","cache","strictTtl","automaticFailover","urlObjectToRequestOptions","Object","fromEntries","entries","map","_ref","key","value","toLowerCase","ee","normalizedUrlString","format","stripWWW","removeTrailingSlash","stripAuthentication","body","undefined","includes","Readable","createHash","update","digest","revalidate","madeRequest","makeRequest","options_","requestErrored","requestErrorCallback","requestErrorPromise","Promise","resolve","handler","response","status","statusCode","revalidatedPolicy","fromObject","cachePolicy","modified","resume","once","convertHeaders","policy","responseHeaders","fromCache","clonedResponse","storable","cloneResponse","bodyPromise","race","toObject","ttl","timeToLive","maxTtl","Math","min","size","key_","keys","runHook","set","error","emit","delete","request_","get","cacheEntry","forceRefresh","satisfiesWithoutRevalidation","Date","now","revalidationHeaders","errorHandler","cachek","on","removeListener","addHook","name","function_","has","removeHook","getHook","_this$hooks$get","_len","arguments","arguments_","Array","_key","uri","namespace","store","bind","clone","autoDestroy","pipe","protocol","auth","hostname","host","port","result","onResponse"],"sources":["C:\\Users\\sakas\\OneDrive\\Desktop\\gogo\\node_modules\\cacheable-request\\src\\index.ts"],"sourcesContent":["import EventEmitter from 'node:events';\nimport urlLib from 'node:url';\nimport crypto from 'node:crypto';\nimport stream, {PassThrough as PassThroughStream} from 'node:stream';\nimport {IncomingMessage} from 'node:http';\nimport normalizeUrl from 'normalize-url';\nimport {getStreamAsBuffer} from 'get-stream';\nimport CachePolicy from 'http-cache-semantics';\nimport Response from 'responselike';\nimport Keyv from 'keyv';\nimport mimicResponse from 'mimic-response';\nimport {\n\tRequestFn, StorageAdapter, CacheResponse, CacheValue, CacheableOptions, UrlOption, CacheError, RequestError, Emitter, CacheableRequestFunction,\n} from './types.js';\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\ntype Function_ = (...arguments_: any[]) => any;\n\nclass CacheableRequest {\n\tcache: StorageAdapter;\n\tcacheRequest: RequestFn;\n\thooks: Map<string, Function_> = new Map<string, Function_>();\n\tconstructor(cacheRequest: RequestFn, cacheAdapter?: StorageAdapter | string) {\n\t\tif (cacheAdapter instanceof Keyv) {\n\t\t\tthis.cache = cacheAdapter;\n\t\t} else if (typeof cacheAdapter === 'string') {\n\t\t\tthis.cache = new Keyv({\n\t\t\t\turi: cacheAdapter,\n\t\t\t\tnamespace: 'cacheable-request',\n\t\t\t});\n\t\t} else {\n\t\t\tthis.cache = new Keyv({\n\t\t\t\tstore: cacheAdapter,\n\t\t\t\tnamespace: 'cacheable-request',\n\t\t\t});\n\t\t}\n\n\t\tthis.request = this.request.bind(this);\n\t\tthis.cacheRequest = cacheRequest;\n\t}\n\n\trequest = () => (options: CacheableOptions,\n\t\tcallback?: (response: CacheResponse) => void): Emitter => {\n\t\tlet url;\n\t\tif (typeof options === 'string') {\n\t\t\turl = normalizeUrlObject(urlLib.parse(options));\n\t\t\toptions = {};\n\t\t} else if (options instanceof urlLib.URL) {\n\t\t\turl = normalizeUrlObject(urlLib.parse(options.toString()));\n\t\t\toptions = {};\n\t\t} else {\n\t\t\tconst [pathname, ...searchParts] = (options.path ?? '').split('?');\n\t\t\tconst search = searchParts.length > 0\n\t\t\t\t? `?${searchParts.join('?')}`\n\t\t\t\t: '';\n\t\t\turl = normalizeUrlObject({...options, pathname, search});\n\t\t}\n\n\t\toptions = {\n\t\t\theaders: {},\n\t\t\tmethod: 'GET',\n\t\t\tcache: true,\n\t\t\tstrictTtl: false,\n\t\t\tautomaticFailover: false,\n\t\t\t...options,\n\t\t\t...urlObjectToRequestOptions(url),\n\t\t};\n\t\toptions.headers = Object.fromEntries(entries(options.headers).map(([key, value]) => [(key as string).toLowerCase(), value]));\n\t\tconst ee: Emitter = new EventEmitter() as Emitter;\n\t\tconst normalizedUrlString = normalizeUrl(urlLib.format(url), {\n\t\t\tstripWWW: false, // eslint-disable-line @typescript-eslint/naming-convention\n\t\t\tremoveTrailingSlash: false,\n\t\t\tstripAuthentication: false,\n\t\t});\n\t\tlet key = `${options.method}:${normalizedUrlString}`;\n\t\t// POST, PATCH, and PUT requests may be cached, depending on the response\n\t\t// cache-control headers. As a result, the body of the request should be\n\t\t// added to the cache key in order to avoid collisions.\n\t\tif (options.body && options.method !== undefined && ['POST', 'PATCH', 'PUT'].includes(options.method)) {\n\t\t\tif (options.body instanceof stream.Readable) {\n\t\t\t\t// Streamed bodies should completely skip the cache because they may\n\t\t\t\t// or may not be hashable and in either case the stream would need to\n\t\t\t\t// close before the cache key could be generated.\n\t\t\t\toptions.cache = false;\n\t\t\t} else {\n\t\t\t\tkey += `:${crypto.createHash('md5').update(options.body).digest('hex')}`;\n\t\t\t}\n\t\t}\n\n\t\tlet revalidate: any = false;\n\t\tlet madeRequest = false;\n\t\tconst makeRequest = (options_: any) => {\n\t\t\tmadeRequest = true;\n\t\t\tlet requestErrored = false;\n\t\t\tlet requestErrorCallback: (...arguments_: any[]) => void = () => {/* do nothing */};\n\n\t\t\tconst requestErrorPromise = new Promise<void>(resolve => {\n\t\t\t\trequestErrorCallback = () => {\n\t\t\t\t\tif (!requestErrored) {\n\t\t\t\t\t\trequestErrored = true;\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t});\n\t\t\tconst handler = async (response: any) => {\n\t\t\t\tif (revalidate) {\n\t\t\t\t\tresponse.status = response.statusCode;\n\t\t\t\t\tconst revalidatedPolicy = CachePolicy.fromObject(revalidate.cachePolicy).revalidatedPolicy(options_, response);\n\t\t\t\t\tif (!revalidatedPolicy.modified) {\n\t\t\t\t\t\tresponse.resume();\n\t\t\t\t\t\tawait new Promise(resolve => {\n\t\t\t\t\t\t\t// Skipping 'error' handler cause 'error' event should't be emitted for 304 response\n\t\t\t\t\t\t\tresponse\n\t\t\t\t\t\t\t\t.once('end', resolve);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tconst headers = convertHeaders(revalidatedPolicy.policy.responseHeaders());\n\t\t\t\t\t\tresponse = new Response({\n\t\t\t\t\t\t\tstatusCode: revalidate.statusCode, headers, body: revalidate.body, url: revalidate.url,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tresponse.cachePolicy = revalidatedPolicy.policy;\n\t\t\t\t\t\tresponse.fromCache = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!response.fromCache) {\n\t\t\t\t\tresponse.cachePolicy = new CachePolicy(options_, response, options_);\n\t\t\t\t\tresponse.fromCache = false;\n\t\t\t\t}\n\n\t\t\t\tlet clonedResponse;\n\t\t\t\tif (options_.cache && response.cachePolicy.storable()) {\n\t\t\t\t\tclonedResponse = cloneResponse(response);\n\t\t\t\t\t(async () => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst bodyPromise = getStreamAsBuffer(response);\n\t\t\t\t\t\t\tawait Promise.race([\n\t\t\t\t\t\t\t\trequestErrorPromise,\n\t\t\t\t\t\t\t\tnew Promise(resolve => response.once('end', resolve)), // eslint-disable-line no-promise-executor-return\n\t\t\t\t\t\t\t\tnew Promise(resolve => response.once('close', resolve)), // eslint-disable-line no-promise-executor-return\n\t\t\t\t\t\t\t]);\n\t\t\t\t\t\t\tconst body = await bodyPromise;\n\t\t\t\t\t\t\tlet value: CacheValue = {\n\t\t\t\t\t\t\t\turl: response.url,\n\t\t\t\t\t\t\t\tstatusCode: response.fromCache ? revalidate.statusCode : response.statusCode,\n\t\t\t\t\t\t\t\tbody,\n\t\t\t\t\t\t\t\tcachePolicy: response.cachePolicy.toObject(),\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tlet ttl = options_.strictTtl ? response.cachePolicy.timeToLive() : undefined;\n\t\t\t\t\t\t\tif (options_.maxTtl) {\n\t\t\t\t\t\t\t\tttl = ttl ? Math.min(ttl, options_.maxTtl) : options_.maxTtl;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (this.hooks.size > 0) {\n\t\t\t\t\t\t\t\t/* eslint-disable no-await-in-loop */\n\t\t\t\t\t\t\t\tfor (const key_ of this.hooks.keys()) {\n\t\t\t\t\t\t\t\t\tvalue = await this.runHook(key_, value, response);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t/* eslint-enable no-await-in-loop */\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tawait this.cache.set(key, value, ttl);\n\t\t\t\t\t\t} catch (error: any) {\n\t\t\t\t\t\t\tee.emit('error', new CacheError(error));\n\t\t\t\t\t\t}\n\t\t\t\t\t})();\n\t\t\t\t} else if (options_.cache && revalidate) {\n\t\t\t\t\t(async () => {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait this.cache.delete(key);\n\t\t\t\t\t\t} catch (error: any) {\n\t\t\t\t\t\t\tee.emit('error', new CacheError(error));\n\t\t\t\t\t\t}\n\t\t\t\t\t})();\n\t\t\t\t}\n\n\t\t\t\tee.emit('response', clonedResponse ?? response);\n\t\t\t\tif (typeof callback === 'function') {\n\t\t\t\t\tcallback(clonedResponse ?? response);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\ttry {\n\t\t\t\tconst request_ = this.cacheRequest(options_, handler);\n\t\t\t\trequest_.once('error', requestErrorCallback);\n\t\t\t\trequest_.once('abort', requestErrorCallback);\n\t\t\t\trequest_.once('destroy', requestErrorCallback);\n\t\t\t\tee.emit('request', request_);\n\t\t\t} catch (error: any) {\n\t\t\t\tee.emit('error', new RequestError(error));\n\t\t\t}\n\t\t};\n\n\t\t(async () => {\n\t\t\tconst get = async (options_: any) => {\n\t\t\t\tawait Promise.resolve();\n\t\t\t\tconst cacheEntry = options_.cache ? await this.cache.get(key) : undefined;\n\n\t\t\t\tif (cacheEntry === undefined && !options_.forceRefresh) {\n\t\t\t\t\tmakeRequest(options_);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst policy = CachePolicy.fromObject(cacheEntry.cachePolicy);\n\t\t\t\tif (policy.satisfiesWithoutRevalidation(options_) && !options_.forceRefresh) {\n\t\t\t\t\tconst headers = convertHeaders(policy.responseHeaders());\n\t\t\t\t\tconst response: any = new Response({\n\t\t\t\t\t\tstatusCode: cacheEntry.statusCode, headers, body: cacheEntry.body, url: cacheEntry.url,\n\t\t\t\t\t});\n\t\t\t\t\tresponse.cachePolicy = policy;\n\t\t\t\t\tresponse.fromCache = true;\n\t\t\t\t\tee.emit('response', response);\n\t\t\t\t\tif (typeof callback === 'function') {\n\t\t\t\t\t\tcallback(response);\n\t\t\t\t\t}\n\t\t\t\t} else if (policy.satisfiesWithoutRevalidation(options_) && Date.now() >= policy.timeToLive() && options_.forceRefresh) {\n\t\t\t\t\tawait this.cache.delete(key);\n\t\t\t\t\toptions_.headers = policy.revalidationHeaders(options_);\n\t\t\t\t\tmakeRequest(options_);\n\t\t\t\t} else {\n\t\t\t\t\trevalidate = cacheEntry;\n\t\t\t\t\toptions_.headers = policy.revalidationHeaders(options_);\n\t\t\t\t\tmakeRequest(options_);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst errorHandler = (error: Error) => ee.emit('error', new CacheError(error));\n\t\t\tif (this.cache instanceof Keyv) {\n\t\t\t\tconst cachek = this.cache;\n\t\t\t\tcachek.once('error', errorHandler);\n\t\t\t\tee.on('error', () => cachek.removeListener('error', errorHandler));\n\t\t\t\tee.on('response', () => cachek.removeListener('error', errorHandler));\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tawait get(options);\n\t\t\t} catch (error: any) {\n\t\t\t\tif (options.automaticFailover && !madeRequest) {\n\t\t\t\t\tmakeRequest(options);\n\t\t\t\t}\n\n\t\t\t\tee.emit('error', new CacheError(error));\n\t\t\t}\n\t\t})();\n\n\t\treturn ee;\n\t};\n\n\taddHook = (name: string, function_: Function_) => {\n\t\tif (!this.hooks.has(name)) {\n\t\t\tthis.hooks.set(name, function_);\n\t\t}\n\t};\n\n\tremoveHook = (name: string) => this.hooks.delete(name);\n\n\tgetHook = (name: string) => this.hooks.get(name);\n\n\trunHook = async (name: string, ...arguments_: any[]): Promise<CacheValue> => this.hooks.get(name)?.(...arguments_);\n}\n\nconst entries = Object.entries as <T>(object: T) => Array<[keyof T, T[keyof T]]>;\n\nconst cloneResponse = (response: IncomingMessage) => {\n\tconst clone = new PassThroughStream({autoDestroy: false});\n\tmimicResponse(response, clone);\n\n\treturn response.pipe(clone);\n};\n\nconst urlObjectToRequestOptions = (url: any) => {\n\tconst options: UrlOption = {...url};\n\toptions.path = `${url.pathname || '/'}${url.search || ''}`;\n\tdelete options.pathname;\n\tdelete options.search;\n\treturn options;\n};\n\nconst normalizeUrlObject = (url: any) =>\n\t// If url was parsed by url.parse or new URL:\n\t// - hostname will be set\n\t// - host will be hostname[:port]\n\t// - port will be set if it was explicit in the parsed string\n\t// Otherwise, url was from request options:\n\t// - hostname or host may be set\n\t// - host shall not have port encoded\n\t({\n\t\tprotocol: url.protocol,\n\t\tauth: url.auth,\n\t\thostname: url.hostname || url.host || 'localhost',\n\t\tport: url.port,\n\t\tpathname: url.pathname,\n\t\tsearch: url.search,\n\t});\n\nconst convertHeaders = (headers: CachePolicy.Headers) => {\n\tconst result: any = [];\n\tfor (const name of Object.keys(headers)) {\n\t\tresult[name.toLowerCase()] = headers[name];\n\t}\n\n\treturn result;\n};\n\nexport default CacheableRequest;\nexport * from './types.js';\nexport const onResponse = 'onResponse';\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}