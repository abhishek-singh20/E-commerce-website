{"ast":null,"code":"'use strict';\n\n/**\n * @typedef {Object} HttpRequest\n * @property {Record<string, string>} headers - Request headers\n * @property {string} [method] - HTTP method\n * @property {string} [url] - Request URL\n */\n\n/**\n * @typedef {Object} HttpResponse\n * @property {Record<string, string>} headers - Response headers\n * @property {number} [status] - HTTP status code\n */\n\n/**\n * Set of default cacheable status codes per RFC 7231 section 6.1.\n * @type {Set<number>}\n */\nconst statusCodeCacheableByDefault = new Set([200, 203, 204, 206, 300, 301, 308, 404, 405, 410, 414, 501]);\n\n/**\n * Set of HTTP status codes that the cache implementation understands.\n * Note: This implementation does not understand partial responses (206).\n * @type {Set<number>}\n */\nconst understoodStatuses = new Set([200, 203, 204, 300, 301, 302, 303, 307, 308, 404, 405, 410, 414, 501]);\n\n/**\n * Set of HTTP error status codes.\n * @type {Set<number>}\n */\nconst errorStatusCodes = new Set([500, 502, 503, 504]);\n\n/**\n * Object representing hop-by-hop headers that should be removed.\n * @type {Record<string, boolean>}\n */\nconst hopByHopHeaders = {\n  date: true,\n  // included, because we add Age update Date\n  connection: true,\n  'keep-alive': true,\n  'proxy-authenticate': true,\n  'proxy-authorization': true,\n  te: true,\n  trailer: true,\n  'transfer-encoding': true,\n  upgrade: true\n};\n\n/**\n * Headers that are excluded from revalidation update.\n * @type {Record<string, boolean>}\n */\nconst excludedFromRevalidationUpdate = {\n  // Since the old body is reused, it doesn't make sense to change properties of the body\n  'content-length': true,\n  'content-encoding': true,\n  'transfer-encoding': true,\n  'content-range': true\n};\n\n/**\n * Converts a string to a number or returns zero if the conversion fails.\n * @param {string} s - The string to convert.\n * @returns {number} The parsed number or 0.\n */\nfunction toNumberOrZero(s) {\n  const n = parseInt(s, 10);\n  return isFinite(n) ? n : 0;\n}\n\n/**\n * Determines if the given response is an error response.\n * Implements RFC 5861 behavior.\n * @param {HttpResponse|undefined} response - The HTTP response object.\n * @returns {boolean} true if the response is an error or undefined, false otherwise.\n */\nfunction isErrorResponse(response) {\n  // consider undefined response as faulty\n  if (!response) {\n    return true;\n  }\n  return errorStatusCodes.has(response.status);\n}\n\n/**\n * Parses a Cache-Control header string into an object.\n * @param {string} [header] - The Cache-Control header value.\n * @returns {Record<string, string|boolean>} An object representing Cache-Control directives.\n */\nfunction parseCacheControl(header) {\n  /** @type {Record<string, string|boolean>} */\n  const cc = {};\n  if (!header) return cc;\n\n  // TODO: When there is more than one value present for a given directive (e.g., two Expires header fields, multiple Cache-Control: max-age directives),\n  // the directive's value is considered invalid. Caches are encouraged to consider responses that have invalid freshness information to be stale\n  const parts = header.trim().split(/,/);\n  for (const part of parts) {\n    const [k, v] = part.split(/=/, 2);\n    cc[k.trim()] = v === undefined ? true : v.trim().replace(/^\"|\"$/g, '');\n  }\n  return cc;\n}\n\n/**\n * Formats a Cache-Control directives object into a header string.\n * @param {Record<string, string|boolean>} cc - The Cache-Control directives.\n * @returns {string|undefined} A formatted Cache-Control header string or undefined if empty.\n */\nfunction formatCacheControl(cc) {\n  let parts = [];\n  for (const k in cc) {\n    const v = cc[k];\n    parts.push(v === true ? k : k + '=' + v);\n  }\n  if (!parts.length) {\n    return undefined;\n  }\n  return parts.join(', ');\n}\nmodule.exports = class CachePolicy {\n  /**\n   * Creates a new CachePolicy instance.\n   * @param {HttpRequest} req - Incoming client request.\n   * @param {HttpResponse} res - Received server response.\n   * @param {Object} [options={}] - Configuration options.\n   * @param {boolean} [options.shared=true] - Is the cache shared (a public proxy)? `false` for personal browser caches.\n   * @param {number} [options.cacheHeuristic=0.1] - Fallback heuristic (age fraction) for cache duration.\n   * @param {number} [options.immutableMinTimeToLive=86400000] - Minimum TTL for immutable responses in milliseconds.\n   * @param {boolean} [options.ignoreCargoCult=false] - Detect nonsense cache headers, and override them.\n   * @param {any} [options._fromObject] - Internal parameter for deserialization. Do not use.\n   */\n  constructor(req, res) {\n    let {\n      shared,\n      cacheHeuristic,\n      immutableMinTimeToLive,\n      ignoreCargoCult,\n      _fromObject\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (_fromObject) {\n      this._fromObject(_fromObject);\n      return;\n    }\n    if (!res || !res.headers) {\n      throw Error('Response headers missing');\n    }\n    this._assertRequestHasHeaders(req);\n\n    /** @type {number} Timestamp when the response was received */\n    this._responseTime = this.now();\n    /** @type {boolean} Indicates if the cache is shared */\n    this._isShared = shared !== false;\n    /** @type {boolean} Indicates if legacy cargo cult directives should be ignored */\n    this._ignoreCargoCult = !!ignoreCargoCult;\n    /** @type {number} Heuristic cache fraction */\n    this._cacheHeuristic = undefined !== cacheHeuristic ? cacheHeuristic : 0.1; // 10% matches IE\n    /** @type {number} Minimum TTL for immutable responses in ms */\n    this._immutableMinTtl = undefined !== immutableMinTimeToLive ? immutableMinTimeToLive : 24 * 3600 * 1000;\n\n    /** @type {number} HTTP status code */\n    this._status = 'status' in res ? res.status : 200;\n    /** @type {Record<string, string>} Response headers */\n    this._resHeaders = res.headers;\n    /** @type {Record<string, string|boolean>} Parsed Cache-Control directives from response */\n    this._rescc = parseCacheControl(res.headers['cache-control']);\n    /** @type {string} HTTP method (e.g., GET, POST) */\n    this._method = 'method' in req ? req.method : 'GET';\n    /** @type {string} Request URL */\n    this._url = req.url;\n    /** @type {string} Host header from the request */\n    this._host = req.headers.host;\n    /** @type {boolean} Whether the request does not include an Authorization header */\n    this._noAuthorization = !req.headers.authorization;\n    /** @type {Record<string, string>|null} Request headers used for Vary matching */\n    this._reqHeaders = res.headers.vary ? req.headers : null; // Don't keep all request headers if they won't be used\n    /** @type {Record<string, string|boolean>} Parsed Cache-Control directives from request */\n    this._reqcc = parseCacheControl(req.headers['cache-control']);\n\n    // Assume that if someone uses legacy, non-standard uncecessary options they don't understand caching,\n    // so there's no point stricly adhering to the blindly copy&pasted directives.\n    if (this._ignoreCargoCult && 'pre-check' in this._rescc && 'post-check' in this._rescc) {\n      delete this._rescc['pre-check'];\n      delete this._rescc['post-check'];\n      delete this._rescc['no-cache'];\n      delete this._rescc['no-store'];\n      delete this._rescc['must-revalidate'];\n      this._resHeaders = Object.assign({}, this._resHeaders, {\n        'cache-control': formatCacheControl(this._rescc)\n      });\n      delete this._resHeaders.expires;\n      delete this._resHeaders.pragma;\n    }\n\n    // When the Cache-Control header field is not present in a request, caches MUST consider the no-cache request pragma-directive\n    // as having the same effect as if \"Cache-Control: no-cache\" were present (see Section 5.2.1).\n    if (res.headers['cache-control'] == null && /no-cache/.test(res.headers.pragma)) {\n      this._rescc['no-cache'] = true;\n    }\n  }\n\n  /**\n   * You can monkey-patch it for testing.\n   * @returns {number} Current time in milliseconds.\n   */\n  now() {\n    return Date.now();\n  }\n\n  /**\n   * Determines if the response is storable in a cache.\n   * @returns {boolean} `false` if can never be cached.\n   */\n  storable() {\n    // The \"no-store\" request directive indicates that a cache MUST NOT store any part of either this request or any response to it.\n    return !!(!this._reqcc['no-store'] && (\n    // A cache MUST NOT store a response to any request, unless:\n    // The request method is understood by the cache and defined as being cacheable, and\n    'GET' === this._method || 'HEAD' === this._method || 'POST' === this._method && this._hasExplicitExpiration()) &&\n    // the response status code is understood by the cache, and\n    understoodStatuses.has(this._status) &&\n    // the \"no-store\" cache directive does not appear in request or response header fields, and\n    !this._rescc['no-store'] && (\n    // the \"private\" response directive does not appear in the response, if the cache is shared, and\n    !this._isShared || !this._rescc.private) && (\n    // the Authorization header field does not appear in the request, if the cache is shared,\n    !this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && (\n    // the response either:\n    // contains an Expires header field, or\n    this._resHeaders.expires ||\n    // contains a max-age response directive, or\n    // contains a s-maxage response directive and the cache is shared, or\n    // contains a public response directive.\n    this._rescc['max-age'] || this._isShared && this._rescc['s-maxage'] || this._rescc.public ||\n    // has a status code that is defined as cacheable by default\n    statusCodeCacheableByDefault.has(this._status)));\n  }\n\n  /**\n   * @returns {boolean} true if expiration is explicitly defined.\n   */\n  _hasExplicitExpiration() {\n    // 4.2.1 Calculating Freshness Lifetime\n    return !!(this._isShared && this._rescc['s-maxage'] || this._rescc['max-age'] || this._resHeaders.expires);\n  }\n\n  /**\n   * @param {HttpRequest} req - a request\n   * @throws {Error} if the headers are missing.\n   */\n  _assertRequestHasHeaders(req) {\n    if (!req || !req.headers) {\n      throw Error('Request headers missing');\n    }\n  }\n\n  /**\n   * Checks if the request matches the cache and can be satisfied from the cache immediately,\n   * without having to make a request to the server.\n   *\n   * This doesn't support `stale-while-revalidate`. See `evaluateRequest()` for a more complete solution.\n   *\n   * @param {HttpRequest} req - The new incoming HTTP request.\n   * @returns {boolean} `true`` if the cached response used to construct this cache policy satisfies the request without revalidation.\n   */\n  satisfiesWithoutRevalidation(req) {\n    const result = this.evaluateRequest(req);\n    return !result.revalidation;\n  }\n\n  /**\n   * @param {{headers: Record<string, string>, synchronous: boolean}|undefined} revalidation - Revalidation information, if any.\n   * @returns {{response: {headers: Record<string, string>}, revalidation: {headers: Record<string, string>, synchronous: boolean}|undefined}} An object with a cached response headers and revalidation info.\n   */\n  _evaluateRequestHitResult(revalidation) {\n    return {\n      response: {\n        headers: this.responseHeaders()\n      },\n      revalidation\n    };\n  }\n\n  /**\n   * @param {HttpRequest} request - new incoming\n   * @param {boolean} synchronous - whether revalidation must be synchronous (not s-w-r).\n   * @returns {{headers: Record<string, string>, synchronous: boolean}} An object with revalidation headers and a synchronous flag.\n   */\n  _evaluateRequestRevalidation(request, synchronous) {\n    return {\n      synchronous,\n      headers: this.revalidationHeaders(request)\n    };\n  }\n\n  /**\n   * @param {HttpRequest} request - new incoming\n   * @returns {{response: undefined, revalidation: {headers: Record<string, string>, synchronous: boolean}}} An object indicating no cached response and revalidation details.\n   */\n  _evaluateRequestMissResult(request) {\n    return {\n      response: undefined,\n      revalidation: this._evaluateRequestRevalidation(request, true)\n    };\n  }\n\n  /**\n   * Checks if the given request matches this cache entry, and how the cache can be used to satisfy it. Returns an object with:\n   *\n   * ```\n   * {\n   *     // If defined, you must send a request to the server.\n   *     revalidation: {\n   *         headers: {}, // HTTP headers to use when sending the revalidation response\n   *         // If true, you MUST wait for a response from the server before using the cache\n   *         // If false, this is stale-while-revalidate. The cache is stale, but you can use it while you update it asynchronously.\n   *         synchronous: bool,\n   *     },\n   *     // If defined, you can use this cached response.\n   *     response: {\n   *         headers: {}, // Updated cached HTTP headers you must use when responding to the client\n   *     },\n   * }\n   * ```\n   * @param {HttpRequest} req - new incoming HTTP request\n   * @returns {{response: {headers: Record<string, string>}|undefined, revalidation: {headers: Record<string, string>, synchronous: boolean}|undefined}} An object containing keys:\n   *   - revalidation: { headers: Record<string, string>, synchronous: boolean } Set if you should send this to the origin server\n   *   - response: { headers: Record<string, string> } Set if you can respond to the client with these cached headers\n   */\n  evaluateRequest(req) {\n    this._assertRequestHasHeaders(req);\n\n    // In all circumstances, a cache MUST NOT ignore the must-revalidate directive\n    if (this._rescc['must-revalidate']) {\n      return this._evaluateRequestMissResult(req);\n    }\n    if (!this._requestMatches(req, false)) {\n      return this._evaluateRequestMissResult(req);\n    }\n\n    // When presented with a request, a cache MUST NOT reuse a stored response, unless:\n    // the presented request does not contain the no-cache pragma (Section 5.4), nor the no-cache cache directive,\n    // unless the stored response is successfully validated (Section 4.3), and\n    const requestCC = parseCacheControl(req.headers['cache-control']);\n    if (requestCC['no-cache'] || /no-cache/.test(req.headers.pragma)) {\n      return this._evaluateRequestMissResult(req);\n    }\n    if (requestCC['max-age'] && this.age() > toNumberOrZero(requestCC['max-age'])) {\n      return this._evaluateRequestMissResult(req);\n    }\n    if (requestCC['min-fresh'] && this.maxAge() - this.age() < toNumberOrZero(requestCC['min-fresh'])) {\n      return this._evaluateRequestMissResult(req);\n    }\n\n    // the stored response is either:\n    // fresh, or allowed to be served stale\n    if (this.stale()) {\n      // If a value is present, then the client is willing to accept a response that has\n      // exceeded its freshness lifetime by no more than the specified number of seconds\n      const allowsStaleWithoutRevalidation = 'max-stale' in requestCC && (true === requestCC['max-stale'] || requestCC['max-stale'] > this.age() - this.maxAge());\n      if (allowsStaleWithoutRevalidation) {\n        return this._evaluateRequestHitResult(undefined);\n      }\n      if (this.useStaleWhileRevalidate()) {\n        return this._evaluateRequestHitResult(this._evaluateRequestRevalidation(req, false));\n      }\n      return this._evaluateRequestMissResult(req);\n    }\n    return this._evaluateRequestHitResult(undefined);\n  }\n\n  /**\n   * @param {HttpRequest} req - check if this is for the same cache entry\n   * @param {boolean} allowHeadMethod - allow a HEAD method to match.\n   * @returns {boolean} `true` if the request matches.\n   */\n  _requestMatches(req, allowHeadMethod) {\n    // The presented effective request URI and that of the stored response match, and\n    return !!((!this._url || this._url === req.url) && this._host === req.headers.host && (\n    // the request method associated with the stored response allows it to be used for the presented request, and\n    !req.method || this._method === req.method || allowHeadMethod && 'HEAD' === req.method) &&\n    // selecting header fields nominated by the stored response (if any) match those presented, and\n    this._varyMatches(req));\n  }\n\n  /**\n   * Determines whether storing authenticated responses is allowed.\n   * @returns {boolean} `true` if allowed.\n   */\n  _allowsStoringAuthenticated() {\n    // following Cache-Control response directives (Section 5.2.2) have such an effect: must-revalidate, public, and s-maxage.\n    return !!(this._rescc['must-revalidate'] || this._rescc.public || this._rescc['s-maxage']);\n  }\n\n  /**\n   * Checks whether the Vary header in the response matches the new request.\n   * @param {HttpRequest} req - incoming HTTP request\n   * @returns {boolean} `true` if the vary headers match.\n   */\n  _varyMatches(req) {\n    if (!this._resHeaders.vary) {\n      return true;\n    }\n\n    // A Vary header field-value of \"*\" always fails to match\n    if (this._resHeaders.vary === '*') {\n      return false;\n    }\n    const fields = this._resHeaders.vary.trim().toLowerCase().split(/\\s*,\\s*/);\n    for (const name of fields) {\n      if (req.headers[name] !== this._reqHeaders[name]) return false;\n    }\n    return true;\n  }\n\n  /**\n   * Creates a copy of the given headers without any hop-by-hop headers.\n   * @param {Record<string, string>} inHeaders - old headers from the cached response\n   * @returns {Record<string, string>} A new headers object without hop-by-hop headers.\n   */\n  _copyWithoutHopByHopHeaders(inHeaders) {\n    /** @type {Record<string, string>} */\n    const headers = {};\n    for (const name in inHeaders) {\n      if (hopByHopHeaders[name]) continue;\n      headers[name] = inHeaders[name];\n    }\n    // 9.1.  Connection\n    if (inHeaders.connection) {\n      const tokens = inHeaders.connection.trim().split(/\\s*,\\s*/);\n      for (const name of tokens) {\n        delete headers[name];\n      }\n    }\n    if (headers.warning) {\n      const warnings = headers.warning.split(/,/).filter(warning => {\n        return !/^\\s*1[0-9][0-9]/.test(warning);\n      });\n      if (!warnings.length) {\n        delete headers.warning;\n      } else {\n        headers.warning = warnings.join(',').trim();\n      }\n    }\n    return headers;\n  }\n\n  /**\n   * Returns the response headers adjusted for serving the cached response.\n   * Removes hop-by-hop headers and updates the Age and Date headers.\n   * @returns {Record<string, string>} The adjusted response headers.\n   */\n  responseHeaders() {\n    const headers = this._copyWithoutHopByHopHeaders(this._resHeaders);\n    const age = this.age();\n\n    // A cache SHOULD generate 113 warning if it heuristically chose a freshness\n    // lifetime greater than 24 hours and the response's age is greater than 24 hours.\n    if (age > 3600 * 24 && !this._hasExplicitExpiration() && this.maxAge() > 3600 * 24) {\n      headers.warning = (headers.warning ? \"\".concat(headers.warning, \", \") : '') + '113 - \"rfc7234 5.5.4\"';\n    }\n    headers.age = \"\".concat(Math.round(age));\n    headers.date = new Date(this.now()).toUTCString();\n    return headers;\n  }\n\n  /**\n   * Returns the Date header value from the response or the current time if invalid.\n   * @returns {number} Timestamp (in milliseconds) representing the Date header or response time.\n   */\n  date() {\n    const serverDate = Date.parse(this._resHeaders.date);\n    if (isFinite(serverDate)) {\n      return serverDate;\n    }\n    return this._responseTime;\n  }\n\n  /**\n   * Value of the Age header, in seconds, updated for the current time.\n   * May be fractional.\n   * @returns {number} The age in seconds.\n   */\n  age() {\n    let age = this._ageValue();\n    const residentTime = (this.now() - this._responseTime) / 1000;\n    return age + residentTime;\n  }\n\n  /**\n   * @returns {number} The Age header value as a number.\n   */\n  _ageValue() {\n    return toNumberOrZero(this._resHeaders.age);\n  }\n\n  /**\n   * Possibly outdated value of applicable max-age (or heuristic equivalent) in seconds.\n   * This counts since response's `Date`.\n   *\n   * For an up-to-date value, see `timeToLive()`.\n   *\n   * Returns the maximum age (freshness lifetime) of the response in seconds.\n   * @returns {number} The max-age value in seconds.\n   */\n  maxAge() {\n    if (!this.storable() || this._rescc['no-cache']) {\n      return 0;\n    }\n\n    // Shared responses with cookies are cacheable according to the RFC, but IMHO it'd be unwise to do so by default\n    // so this implementation requires explicit opt-in via public header\n    if (this._isShared && this._resHeaders['set-cookie'] && !this._rescc.public && !this._rescc.immutable) {\n      return 0;\n    }\n    if (this._resHeaders.vary === '*') {\n      return 0;\n    }\n    if (this._isShared) {\n      if (this._rescc['proxy-revalidate']) {\n        return 0;\n      }\n      // if a response includes the s-maxage directive, a shared cache recipient MUST ignore the Expires field.\n      if (this._rescc['s-maxage']) {\n        return toNumberOrZero(this._rescc['s-maxage']);\n      }\n    }\n\n    // If a response includes a Cache-Control field with the max-age directive, a recipient MUST ignore the Expires field.\n    if (this._rescc['max-age']) {\n      return toNumberOrZero(this._rescc['max-age']);\n    }\n    const defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;\n    const serverDate = this.date();\n    if (this._resHeaders.expires) {\n      const expires = Date.parse(this._resHeaders.expires);\n      // A cache recipient MUST interpret invalid date formats, especially the value \"0\", as representing a time in the past (i.e., \"already expired\").\n      if (Number.isNaN(expires) || expires < serverDate) {\n        return 0;\n      }\n      return Math.max(defaultMinTtl, (expires - serverDate) / 1000);\n    }\n    if (this._resHeaders['last-modified']) {\n      const lastModified = Date.parse(this._resHeaders['last-modified']);\n      if (isFinite(lastModified) && serverDate > lastModified) {\n        return Math.max(defaultMinTtl, (serverDate - lastModified) / 1000 * this._cacheHeuristic);\n      }\n    }\n    return defaultMinTtl;\n  }\n\n  /**\n   * Remaining time this cache entry may be useful for, in *milliseconds*.\n   * You can use this as an expiration time for your cache storage.\n   *\n   * Prefer this method over `maxAge()`, because it includes other factors like `age` and `stale-while-revalidate`.\n   * @returns {number} Time-to-live in milliseconds.\n   */\n  timeToLive() {\n    const age = this.maxAge() - this.age();\n    const staleIfErrorAge = age + toNumberOrZero(this._rescc['stale-if-error']);\n    const staleWhileRevalidateAge = age + toNumberOrZero(this._rescc['stale-while-revalidate']);\n    return Math.round(Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1000);\n  }\n\n  /**\n   * If true, this cache entry is past its expiration date.\n   * Note that stale cache may be useful sometimes, see `evaluateRequest()`.\n   * @returns {boolean} `false` doesn't mean it's fresh nor usable\n   */\n  stale() {\n    return this.maxAge() <= this.age();\n  }\n\n  /**\n   * @returns {boolean} `true` if `stale-if-error` condition allows use of a stale response.\n   */\n  _useStaleIfError() {\n    return this.maxAge() + toNumberOrZero(this._rescc['stale-if-error']) > this.age();\n  }\n\n  /** See `evaluateRequest()` for a more complete solution\n   * @returns {boolean} `true` if `stale-while-revalidate` is currently allowed.\n   */\n  useStaleWhileRevalidate() {\n    const swr = toNumberOrZero(this._rescc['stale-while-revalidate']);\n    return swr > 0 && this.maxAge() + swr > this.age();\n  }\n\n  /**\n   * Creates a `CachePolicy` instance from a serialized object.\n   * @param {Object} obj - The serialized object.\n   * @returns {CachePolicy} A new CachePolicy instance.\n   */\n  static fromObject(obj) {\n    return new this(undefined, undefined, {\n      _fromObject: obj\n    });\n  }\n\n  /**\n   * @param {any} obj - The serialized object.\n   * @throws {Error} If already initialized or if the object is invalid.\n   */\n  _fromObject(obj) {\n    if (this._responseTime) throw Error('Reinitialized');\n    if (!obj || obj.v !== 1) throw Error('Invalid serialization');\n    this._responseTime = obj.t;\n    this._isShared = obj.sh;\n    this._cacheHeuristic = obj.ch;\n    this._immutableMinTtl = obj.imm !== undefined ? obj.imm : 24 * 3600 * 1000;\n    this._ignoreCargoCult = !!obj.icc;\n    this._status = obj.st;\n    this._resHeaders = obj.resh;\n    this._rescc = obj.rescc;\n    this._method = obj.m;\n    this._url = obj.u;\n    this._host = obj.h;\n    this._noAuthorization = obj.a;\n    this._reqHeaders = obj.reqh;\n    this._reqcc = obj.reqcc;\n  }\n\n  /**\n   * Serializes the `CachePolicy` instance into a JSON-serializable object.\n   * @returns {Object} The serialized object.\n   */\n  toObject() {\n    return {\n      v: 1,\n      t: this._responseTime,\n      sh: this._isShared,\n      ch: this._cacheHeuristic,\n      imm: this._immutableMinTtl,\n      icc: this._ignoreCargoCult,\n      st: this._status,\n      resh: this._resHeaders,\n      rescc: this._rescc,\n      m: this._method,\n      u: this._url,\n      h: this._host,\n      a: this._noAuthorization,\n      reqh: this._reqHeaders,\n      reqcc: this._reqcc\n    };\n  }\n\n  /**\n   * Headers for sending to the origin server to revalidate stale response.\n   * Allows server to return 304 to allow reuse of the previous response.\n   *\n   * Hop by hop headers are always stripped.\n   * Revalidation headers may be added or removed, depending on request.\n   * @param {HttpRequest} incomingReq - The incoming HTTP request.\n   * @returns {Record<string, string>} The headers for the revalidation request.\n   */\n  revalidationHeaders(incomingReq) {\n    this._assertRequestHasHeaders(incomingReq);\n    const headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);\n\n    // This implementation does not understand range requests\n    delete headers['if-range'];\n    if (!this._requestMatches(incomingReq, true) || !this.storable()) {\n      // revalidation allowed via HEAD\n      // not for the same resource, or wasn't allowed to be cached anyway\n      delete headers['if-none-match'];\n      delete headers['if-modified-since'];\n      return headers;\n    }\n\n    /* MUST send that entity-tag in any cache validation request (using If-Match or If-None-Match) if an entity-tag has been provided by the origin server. */\n    if (this._resHeaders.etag) {\n      headers['if-none-match'] = headers['if-none-match'] ? \"\".concat(headers['if-none-match'], \", \").concat(this._resHeaders.etag) : this._resHeaders.etag;\n    }\n\n    // Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators. Clients MUST NOT use weak validators in other forms of request.\n    const forbidsWeakValidators = headers['accept-ranges'] || headers['if-match'] || headers['if-unmodified-since'] || this._method && this._method != 'GET';\n\n    /* SHOULD send the Last-Modified value in non-subrange cache validation requests (using If-Modified-Since) if only a Last-Modified value has been provided by the origin server.\n    Note: This implementation does not understand partial responses (206) */\n    if (forbidsWeakValidators) {\n      delete headers['if-modified-since'];\n      if (headers['if-none-match']) {\n        const etags = headers['if-none-match'].split(/,/).filter(etag => {\n          return !/^\\s*W\\//.test(etag);\n        });\n        if (!etags.length) {\n          delete headers['if-none-match'];\n        } else {\n          headers['if-none-match'] = etags.join(',').trim();\n        }\n      }\n    } else if (this._resHeaders['last-modified'] && !headers['if-modified-since']) {\n      headers['if-modified-since'] = this._resHeaders['last-modified'];\n    }\n    return headers;\n  }\n\n  /**\n   * Creates new CachePolicy with information combined from the previews response,\n   * and the new revalidation response.\n   *\n   * Returns {policy, modified} where modified is a boolean indicating\n   * whether the response body has been modified, and old cached body can't be used.\n   *\n   * @param {HttpRequest} request - The latest HTTP request asking for the cached entry.\n   * @param {HttpResponse} response - The latest revalidation HTTP response from the origin server.\n   * @returns {{policy: CachePolicy, modified: boolean, matches: boolean}} The updated policy and modification status.\n   * @throws {Error} If the response headers are missing.\n   */\n  revalidatedPolicy(request, response) {\n    this._assertRequestHasHeaders(request);\n    if (this._useStaleIfError() && isErrorResponse(response)) {\n      return {\n        policy: this,\n        modified: false,\n        matches: true\n      };\n    }\n    if (!response || !response.headers) {\n      throw Error('Response headers missing');\n    }\n\n    // These aren't going to be supported exactly, since one CachePolicy object\n    // doesn't know about all the other cached objects.\n    let matches = false;\n    if (response.status !== undefined && response.status != 304) {\n      matches = false;\n    } else if (response.headers.etag && !/^\\s*W\\//.test(response.headers.etag)) {\n      // \"All of the stored responses with the same strong validator are selected.\n      // If none of the stored responses contain the same strong validator,\n      // then the cache MUST NOT use the new response to update any stored responses.\"\n      matches = this._resHeaders.etag && this._resHeaders.etag.replace(/^\\s*W\\//, '') === response.headers.etag;\n    } else if (this._resHeaders.etag && response.headers.etag) {\n      // \"If the new response contains a weak validator and that validator corresponds\n      // to one of the cache's stored responses,\n      // then the most recent of those matching stored responses is selected for update.\"\n      matches = this._resHeaders.etag.replace(/^\\s*W\\//, '') === response.headers.etag.replace(/^\\s*W\\//, '');\n    } else if (this._resHeaders['last-modified']) {\n      matches = this._resHeaders['last-modified'] === response.headers['last-modified'];\n    } else {\n      // If the new response does not include any form of validator (such as in the case where\n      // a client generates an If-Modified-Since request from a source other than the Last-Modified\n      // response header field), and there is only one stored response, and that stored response also\n      // lacks a validator, then that stored response is selected for update.\n      if (!this._resHeaders.etag && !this._resHeaders['last-modified'] && !response.headers.etag && !response.headers['last-modified']) {\n        matches = true;\n      }\n    }\n    const optionsCopy = {\n      shared: this._isShared,\n      cacheHeuristic: this._cacheHeuristic,\n      immutableMinTimeToLive: this._immutableMinTtl,\n      ignoreCargoCult: this._ignoreCargoCult\n    };\n    if (!matches) {\n      return {\n        policy: new this.constructor(request, response, optionsCopy),\n        // Client receiving 304 without body, even if it's invalid/mismatched has no option\n        // but to reuse a cached body. We don't have a good way to tell clients to do\n        // error recovery in such case.\n        modified: response.status != 304,\n        matches: false\n      };\n    }\n\n    // use other header fields provided in the 304 (Not Modified) response to replace all instances\n    // of the corresponding header fields in the stored response.\n    const headers = {};\n    for (const k in this._resHeaders) {\n      headers[k] = k in response.headers && !excludedFromRevalidationUpdate[k] ? response.headers[k] : this._resHeaders[k];\n    }\n    const newResponse = Object.assign({}, response, {\n      status: this._status,\n      method: this._method,\n      headers\n    });\n    return {\n      policy: new this.constructor(request, newResponse, optionsCopy),\n      modified: false,\n      matches: true\n    };\n  }\n};","map":{"version":3,"names":["statusCodeCacheableByDefault","Set","understoodStatuses","errorStatusCodes","hopByHopHeaders","date","connection","te","trailer","upgrade","excludedFromRevalidationUpdate","toNumberOrZero","s","n","parseInt","isFinite","isErrorResponse","response","has","status","parseCacheControl","header","cc","parts","trim","split","part","k","v","undefined","replace","formatCacheControl","push","length","join","module","exports","CachePolicy","constructor","req","res","shared","cacheHeuristic","immutableMinTimeToLive","ignoreCargoCult","_fromObject","arguments","headers","Error","_assertRequestHasHeaders","_responseTime","now","_isShared","_ignoreCargoCult","_cacheHeuristic","_immutableMinTtl","_status","_resHeaders","_rescc","_method","method","_url","url","_host","host","_noAuthorization","authorization","_reqHeaders","vary","_reqcc","Object","assign","expires","pragma","test","Date","storable","_hasExplicitExpiration","private","_allowsStoringAuthenticated","public","satisfiesWithoutRevalidation","result","evaluateRequest","revalidation","_evaluateRequestHitResult","responseHeaders","_evaluateRequestRevalidation","request","synchronous","revalidationHeaders","_evaluateRequestMissResult","_requestMatches","requestCC","age","maxAge","stale","allowsStaleWithoutRevalidation","useStaleWhileRevalidate","allowHeadMethod","_varyMatches","fields","toLowerCase","name","_copyWithoutHopByHopHeaders","inHeaders","tokens","warning","warnings","filter","concat","Math","round","toUTCString","serverDate","parse","_ageValue","residentTime","immutable","defaultMinTtl","Number","isNaN","max","lastModified","timeToLive","staleIfErrorAge","staleWhileRevalidateAge","_useStaleIfError","swr","fromObject","obj","t","sh","ch","imm","icc","st","resh","rescc","m","u","h","a","reqh","reqcc","toObject","incomingReq","etag","forbidsWeakValidators","etags","revalidatedPolicy","policy","modified","matches","optionsCopy","newResponse"],"sources":["C:/Users/sakas/OneDrive/Desktop/gogo/node_modules/http-cache-semantics/index.js"],"sourcesContent":["'use strict';\n\n/**\n * @typedef {Object} HttpRequest\n * @property {Record<string, string>} headers - Request headers\n * @property {string} [method] - HTTP method\n * @property {string} [url] - Request URL\n */\n\n/**\n * @typedef {Object} HttpResponse\n * @property {Record<string, string>} headers - Response headers\n * @property {number} [status] - HTTP status code\n */\n\n/**\n * Set of default cacheable status codes per RFC 7231 section 6.1.\n * @type {Set<number>}\n */\nconst statusCodeCacheableByDefault = new Set([\n    200,\n    203,\n    204,\n    206,\n    300,\n    301,\n    308,\n    404,\n    405,\n    410,\n    414,\n    501,\n]);\n\n/**\n * Set of HTTP status codes that the cache implementation understands.\n * Note: This implementation does not understand partial responses (206).\n * @type {Set<number>}\n */\nconst understoodStatuses = new Set([\n    200,\n    203,\n    204,\n    300,\n    301,\n    302,\n    303,\n    307,\n    308,\n    404,\n    405,\n    410,\n    414,\n    501,\n]);\n\n/**\n * Set of HTTP error status codes.\n * @type {Set<number>}\n */\nconst errorStatusCodes = new Set([\n    500,\n    502,\n    503,\n    504,\n]);\n\n/**\n * Object representing hop-by-hop headers that should be removed.\n * @type {Record<string, boolean>}\n */\nconst hopByHopHeaders = {\n    date: true, // included, because we add Age update Date\n    connection: true,\n    'keep-alive': true,\n    'proxy-authenticate': true,\n    'proxy-authorization': true,\n    te: true,\n    trailer: true,\n    'transfer-encoding': true,\n    upgrade: true,\n};\n\n/**\n * Headers that are excluded from revalidation update.\n * @type {Record<string, boolean>}\n */\nconst excludedFromRevalidationUpdate = {\n    // Since the old body is reused, it doesn't make sense to change properties of the body\n    'content-length': true,\n    'content-encoding': true,\n    'transfer-encoding': true,\n    'content-range': true,\n};\n\n/**\n * Converts a string to a number or returns zero if the conversion fails.\n * @param {string} s - The string to convert.\n * @returns {number} The parsed number or 0.\n */\nfunction toNumberOrZero(s) {\n    const n = parseInt(s, 10);\n    return isFinite(n) ? n : 0;\n}\n\n/**\n * Determines if the given response is an error response.\n * Implements RFC 5861 behavior.\n * @param {HttpResponse|undefined} response - The HTTP response object.\n * @returns {boolean} true if the response is an error or undefined, false otherwise.\n */\nfunction isErrorResponse(response) {\n    // consider undefined response as faulty\n    if (!response) {\n        return true;\n    }\n    return errorStatusCodes.has(response.status);\n}\n\n/**\n * Parses a Cache-Control header string into an object.\n * @param {string} [header] - The Cache-Control header value.\n * @returns {Record<string, string|boolean>} An object representing Cache-Control directives.\n */\nfunction parseCacheControl(header) {\n    /** @type {Record<string, string|boolean>} */\n    const cc = {};\n    if (!header) return cc;\n\n    // TODO: When there is more than one value present for a given directive (e.g., two Expires header fields, multiple Cache-Control: max-age directives),\n    // the directive's value is considered invalid. Caches are encouraged to consider responses that have invalid freshness information to be stale\n    const parts = header.trim().split(/,/);\n    for (const part of parts) {\n        const [k, v] = part.split(/=/, 2);\n        cc[k.trim()] = v === undefined ? true : v.trim().replace(/^\"|\"$/g, '');\n    }\n\n    return cc;\n}\n\n/**\n * Formats a Cache-Control directives object into a header string.\n * @param {Record<string, string|boolean>} cc - The Cache-Control directives.\n * @returns {string|undefined} A formatted Cache-Control header string or undefined if empty.\n */\nfunction formatCacheControl(cc) {\n    let parts = [];\n    for (const k in cc) {\n        const v = cc[k];\n        parts.push(v === true ? k : k + '=' + v);\n    }\n    if (!parts.length) {\n        return undefined;\n    }\n    return parts.join(', ');\n}\n\nmodule.exports = class CachePolicy {\n    /**\n     * Creates a new CachePolicy instance.\n     * @param {HttpRequest} req - Incoming client request.\n     * @param {HttpResponse} res - Received server response.\n     * @param {Object} [options={}] - Configuration options.\n     * @param {boolean} [options.shared=true] - Is the cache shared (a public proxy)? `false` for personal browser caches.\n     * @param {number} [options.cacheHeuristic=0.1] - Fallback heuristic (age fraction) for cache duration.\n     * @param {number} [options.immutableMinTimeToLive=86400000] - Minimum TTL for immutable responses in milliseconds.\n     * @param {boolean} [options.ignoreCargoCult=false] - Detect nonsense cache headers, and override them.\n     * @param {any} [options._fromObject] - Internal parameter for deserialization. Do not use.\n     */\n    constructor(\n        req,\n        res,\n        {\n            shared,\n            cacheHeuristic,\n            immutableMinTimeToLive,\n            ignoreCargoCult,\n            _fromObject,\n        } = {}\n    ) {\n        if (_fromObject) {\n            this._fromObject(_fromObject);\n            return;\n        }\n\n        if (!res || !res.headers) {\n            throw Error('Response headers missing');\n        }\n        this._assertRequestHasHeaders(req);\n\n        /** @type {number} Timestamp when the response was received */\n        this._responseTime = this.now();\n        /** @type {boolean} Indicates if the cache is shared */\n        this._isShared = shared !== false;\n        /** @type {boolean} Indicates if legacy cargo cult directives should be ignored */\n        this._ignoreCargoCult = !!ignoreCargoCult;\n        /** @type {number} Heuristic cache fraction */\n        this._cacheHeuristic =\n            undefined !== cacheHeuristic ? cacheHeuristic : 0.1; // 10% matches IE\n        /** @type {number} Minimum TTL for immutable responses in ms */\n        this._immutableMinTtl =\n            undefined !== immutableMinTimeToLive\n                ? immutableMinTimeToLive\n                : 24 * 3600 * 1000;\n\n        /** @type {number} HTTP status code */\n        this._status = 'status' in res ? res.status : 200;\n        /** @type {Record<string, string>} Response headers */\n        this._resHeaders = res.headers;\n        /** @type {Record<string, string|boolean>} Parsed Cache-Control directives from response */\n        this._rescc = parseCacheControl(res.headers['cache-control']);\n        /** @type {string} HTTP method (e.g., GET, POST) */\n        this._method = 'method' in req ? req.method : 'GET';\n        /** @type {string} Request URL */\n        this._url = req.url;\n        /** @type {string} Host header from the request */\n        this._host = req.headers.host;\n        /** @type {boolean} Whether the request does not include an Authorization header */\n        this._noAuthorization = !req.headers.authorization;\n        /** @type {Record<string, string>|null} Request headers used for Vary matching */\n        this._reqHeaders = res.headers.vary ? req.headers : null; // Don't keep all request headers if they won't be used\n        /** @type {Record<string, string|boolean>} Parsed Cache-Control directives from request */\n        this._reqcc = parseCacheControl(req.headers['cache-control']);\n\n        // Assume that if someone uses legacy, non-standard uncecessary options they don't understand caching,\n        // so there's no point stricly adhering to the blindly copy&pasted directives.\n        if (\n            this._ignoreCargoCult &&\n            'pre-check' in this._rescc &&\n            'post-check' in this._rescc\n        ) {\n            delete this._rescc['pre-check'];\n            delete this._rescc['post-check'];\n            delete this._rescc['no-cache'];\n            delete this._rescc['no-store'];\n            delete this._rescc['must-revalidate'];\n            this._resHeaders = Object.assign({}, this._resHeaders, {\n                'cache-control': formatCacheControl(this._rescc),\n            });\n            delete this._resHeaders.expires;\n            delete this._resHeaders.pragma;\n        }\n\n        // When the Cache-Control header field is not present in a request, caches MUST consider the no-cache request pragma-directive\n        // as having the same effect as if \"Cache-Control: no-cache\" were present (see Section 5.2.1).\n        if (\n            res.headers['cache-control'] == null &&\n            /no-cache/.test(res.headers.pragma)\n        ) {\n            this._rescc['no-cache'] = true;\n        }\n    }\n\n    /**\n     * You can monkey-patch it for testing.\n     * @returns {number} Current time in milliseconds.\n     */\n    now() {\n        return Date.now();\n    }\n\n    /**\n     * Determines if the response is storable in a cache.\n     * @returns {boolean} `false` if can never be cached.\n     */\n    storable() {\n        // The \"no-store\" request directive indicates that a cache MUST NOT store any part of either this request or any response to it.\n        return !!(\n            !this._reqcc['no-store'] &&\n            // A cache MUST NOT store a response to any request, unless:\n            // The request method is understood by the cache and defined as being cacheable, and\n            ('GET' === this._method ||\n                'HEAD' === this._method ||\n                ('POST' === this._method && this._hasExplicitExpiration())) &&\n            // the response status code is understood by the cache, and\n            understoodStatuses.has(this._status) &&\n            // the \"no-store\" cache directive does not appear in request or response header fields, and\n            !this._rescc['no-store'] &&\n            // the \"private\" response directive does not appear in the response, if the cache is shared, and\n            (!this._isShared || !this._rescc.private) &&\n            // the Authorization header field does not appear in the request, if the cache is shared,\n            (!this._isShared ||\n                this._noAuthorization ||\n                this._allowsStoringAuthenticated()) &&\n            // the response either:\n            // contains an Expires header field, or\n            (this._resHeaders.expires ||\n                // contains a max-age response directive, or\n                // contains a s-maxage response directive and the cache is shared, or\n                // contains a public response directive.\n                this._rescc['max-age'] ||\n                (this._isShared && this._rescc['s-maxage']) ||\n                this._rescc.public ||\n                // has a status code that is defined as cacheable by default\n                statusCodeCacheableByDefault.has(this._status))\n        );\n    }\n\n    /**\n     * @returns {boolean} true if expiration is explicitly defined.\n     */\n    _hasExplicitExpiration() {\n        // 4.2.1 Calculating Freshness Lifetime\n        return !!(\n            (this._isShared && this._rescc['s-maxage']) ||\n            this._rescc['max-age'] ||\n            this._resHeaders.expires\n        );\n    }\n\n    /**\n     * @param {HttpRequest} req - a request\n     * @throws {Error} if the headers are missing.\n     */\n    _assertRequestHasHeaders(req) {\n        if (!req || !req.headers) {\n            throw Error('Request headers missing');\n        }\n    }\n\n    /**\n     * Checks if the request matches the cache and can be satisfied from the cache immediately,\n     * without having to make a request to the server.\n     *\n     * This doesn't support `stale-while-revalidate`. See `evaluateRequest()` for a more complete solution.\n     *\n     * @param {HttpRequest} req - The new incoming HTTP request.\n     * @returns {boolean} `true`` if the cached response used to construct this cache policy satisfies the request without revalidation.\n     */\n    satisfiesWithoutRevalidation(req) {\n        const result = this.evaluateRequest(req);\n        return !result.revalidation;\n    }\n\n    /**\n     * @param {{headers: Record<string, string>, synchronous: boolean}|undefined} revalidation - Revalidation information, if any.\n     * @returns {{response: {headers: Record<string, string>}, revalidation: {headers: Record<string, string>, synchronous: boolean}|undefined}} An object with a cached response headers and revalidation info.\n     */\n    _evaluateRequestHitResult(revalidation) {\n        return {\n            response: {\n                headers: this.responseHeaders(),\n            },\n            revalidation,\n        };\n    }\n\n    /**\n     * @param {HttpRequest} request - new incoming\n     * @param {boolean} synchronous - whether revalidation must be synchronous (not s-w-r).\n     * @returns {{headers: Record<string, string>, synchronous: boolean}} An object with revalidation headers and a synchronous flag.\n     */\n    _evaluateRequestRevalidation(request, synchronous) {\n        return {\n            synchronous,\n            headers: this.revalidationHeaders(request),\n        };\n    }\n\n    /**\n     * @param {HttpRequest} request - new incoming\n     * @returns {{response: undefined, revalidation: {headers: Record<string, string>, synchronous: boolean}}} An object indicating no cached response and revalidation details.\n     */\n    _evaluateRequestMissResult(request) {\n        return {\n            response: undefined,\n            revalidation: this._evaluateRequestRevalidation(request, true),\n        };\n    }\n\n    /**\n     * Checks if the given request matches this cache entry, and how the cache can be used to satisfy it. Returns an object with:\n     *\n     * ```\n     * {\n     *     // If defined, you must send a request to the server.\n     *     revalidation: {\n     *         headers: {}, // HTTP headers to use when sending the revalidation response\n     *         // If true, you MUST wait for a response from the server before using the cache\n     *         // If false, this is stale-while-revalidate. The cache is stale, but you can use it while you update it asynchronously.\n     *         synchronous: bool,\n     *     },\n     *     // If defined, you can use this cached response.\n     *     response: {\n     *         headers: {}, // Updated cached HTTP headers you must use when responding to the client\n     *     },\n     * }\n     * ```\n     * @param {HttpRequest} req - new incoming HTTP request\n     * @returns {{response: {headers: Record<string, string>}|undefined, revalidation: {headers: Record<string, string>, synchronous: boolean}|undefined}} An object containing keys:\n     *   - revalidation: { headers: Record<string, string>, synchronous: boolean } Set if you should send this to the origin server\n     *   - response: { headers: Record<string, string> } Set if you can respond to the client with these cached headers\n     */\n    evaluateRequest(req) {\n        this._assertRequestHasHeaders(req);\n\n        // In all circumstances, a cache MUST NOT ignore the must-revalidate directive\n        if (this._rescc['must-revalidate']) {\n            return this._evaluateRequestMissResult(req);\n        }\n\n        if (!this._requestMatches(req, false)) {\n            return this._evaluateRequestMissResult(req);\n        }\n\n        // When presented with a request, a cache MUST NOT reuse a stored response, unless:\n        // the presented request does not contain the no-cache pragma (Section 5.4), nor the no-cache cache directive,\n        // unless the stored response is successfully validated (Section 4.3), and\n        const requestCC = parseCacheControl(req.headers['cache-control']);\n\n        if (requestCC['no-cache'] || /no-cache/.test(req.headers.pragma)) {\n            return this._evaluateRequestMissResult(req);\n        }\n\n        if (requestCC['max-age'] && this.age() > toNumberOrZero(requestCC['max-age'])) {\n            return this._evaluateRequestMissResult(req);\n        }\n\n        if (requestCC['min-fresh'] && this.maxAge() - this.age() < toNumberOrZero(requestCC['min-fresh'])) {\n            return this._evaluateRequestMissResult(req);\n        }\n\n        // the stored response is either:\n        // fresh, or allowed to be served stale\n        if (this.stale()) {\n            // If a value is present, then the client is willing to accept a response that has\n            // exceeded its freshness lifetime by no more than the specified number of seconds\n            const allowsStaleWithoutRevalidation = 'max-stale' in requestCC &&\n                (true === requestCC['max-stale'] || requestCC['max-stale'] > this.age() - this.maxAge());\n\n            if (allowsStaleWithoutRevalidation) {\n                return this._evaluateRequestHitResult(undefined);\n            }\n\n            if (this.useStaleWhileRevalidate()) {\n                return this._evaluateRequestHitResult(this._evaluateRequestRevalidation(req, false));\n            }\n\n            return this._evaluateRequestMissResult(req);\n        }\n\n        return this._evaluateRequestHitResult(undefined);\n    }\n\n    /**\n     * @param {HttpRequest} req - check if this is for the same cache entry\n     * @param {boolean} allowHeadMethod - allow a HEAD method to match.\n     * @returns {boolean} `true` if the request matches.\n     */\n    _requestMatches(req, allowHeadMethod) {\n        // The presented effective request URI and that of the stored response match, and\n        return !!(\n            (!this._url || this._url === req.url) &&\n            this._host === req.headers.host &&\n            // the request method associated with the stored response allows it to be used for the presented request, and\n            (!req.method ||\n                this._method === req.method ||\n                (allowHeadMethod && 'HEAD' === req.method)) &&\n            // selecting header fields nominated by the stored response (if any) match those presented, and\n            this._varyMatches(req)\n        );\n    }\n\n    /**\n     * Determines whether storing authenticated responses is allowed.\n     * @returns {boolean} `true` if allowed.\n     */\n    _allowsStoringAuthenticated() {\n        // following Cache-Control response directives (Section 5.2.2) have such an effect: must-revalidate, public, and s-maxage.\n        return !!(\n            this._rescc['must-revalidate'] ||\n            this._rescc.public ||\n            this._rescc['s-maxage']\n        );\n    }\n\n    /**\n     * Checks whether the Vary header in the response matches the new request.\n     * @param {HttpRequest} req - incoming HTTP request\n     * @returns {boolean} `true` if the vary headers match.\n     */\n    _varyMatches(req) {\n        if (!this._resHeaders.vary) {\n            return true;\n        }\n\n        // A Vary header field-value of \"*\" always fails to match\n        if (this._resHeaders.vary === '*') {\n            return false;\n        }\n\n        const fields = this._resHeaders.vary\n            .trim()\n            .toLowerCase()\n            .split(/\\s*,\\s*/);\n        for (const name of fields) {\n            if (req.headers[name] !== this._reqHeaders[name]) return false;\n        }\n        return true;\n    }\n\n    /**\n     * Creates a copy of the given headers without any hop-by-hop headers.\n     * @param {Record<string, string>} inHeaders - old headers from the cached response\n     * @returns {Record<string, string>} A new headers object without hop-by-hop headers.\n     */\n    _copyWithoutHopByHopHeaders(inHeaders) {\n        /** @type {Record<string, string>} */\n        const headers = {};\n        for (const name in inHeaders) {\n            if (hopByHopHeaders[name]) continue;\n            headers[name] = inHeaders[name];\n        }\n        // 9.1.  Connection\n        if (inHeaders.connection) {\n            const tokens = inHeaders.connection.trim().split(/\\s*,\\s*/);\n            for (const name of tokens) {\n                delete headers[name];\n            }\n        }\n        if (headers.warning) {\n            const warnings = headers.warning.split(/,/).filter(warning => {\n                return !/^\\s*1[0-9][0-9]/.test(warning);\n            });\n            if (!warnings.length) {\n                delete headers.warning;\n            } else {\n                headers.warning = warnings.join(',').trim();\n            }\n        }\n        return headers;\n    }\n\n    /**\n     * Returns the response headers adjusted for serving the cached response.\n     * Removes hop-by-hop headers and updates the Age and Date headers.\n     * @returns {Record<string, string>} The adjusted response headers.\n     */\n    responseHeaders() {\n        const headers = this._copyWithoutHopByHopHeaders(this._resHeaders);\n        const age = this.age();\n\n        // A cache SHOULD generate 113 warning if it heuristically chose a freshness\n        // lifetime greater than 24 hours and the response's age is greater than 24 hours.\n        if (\n            age > 3600 * 24 &&\n            !this._hasExplicitExpiration() &&\n            this.maxAge() > 3600 * 24\n        ) {\n            headers.warning =\n                (headers.warning ? `${headers.warning}, ` : '') +\n                '113 - \"rfc7234 5.5.4\"';\n        }\n        headers.age = `${Math.round(age)}`;\n        headers.date = new Date(this.now()).toUTCString();\n        return headers;\n    }\n\n    /**\n     * Returns the Date header value from the response or the current time if invalid.\n     * @returns {number} Timestamp (in milliseconds) representing the Date header or response time.\n     */\n    date() {\n        const serverDate = Date.parse(this._resHeaders.date);\n        if (isFinite(serverDate)) {\n            return serverDate;\n        }\n        return this._responseTime;\n    }\n\n    /**\n     * Value of the Age header, in seconds, updated for the current time.\n     * May be fractional.\n     * @returns {number} The age in seconds.\n     */\n    age() {\n        let age = this._ageValue();\n\n        const residentTime = (this.now() - this._responseTime) / 1000;\n        return age + residentTime;\n    }\n\n    /**\n     * @returns {number} The Age header value as a number.\n     */\n    _ageValue() {\n        return toNumberOrZero(this._resHeaders.age);\n    }\n\n    /**\n     * Possibly outdated value of applicable max-age (or heuristic equivalent) in seconds.\n     * This counts since response's `Date`.\n     *\n     * For an up-to-date value, see `timeToLive()`.\n     *\n     * Returns the maximum age (freshness lifetime) of the response in seconds.\n     * @returns {number} The max-age value in seconds.\n     */\n    maxAge() {\n        if (!this.storable() || this._rescc['no-cache']) {\n            return 0;\n        }\n\n        // Shared responses with cookies are cacheable according to the RFC, but IMHO it'd be unwise to do so by default\n        // so this implementation requires explicit opt-in via public header\n        if (\n            this._isShared &&\n            (this._resHeaders['set-cookie'] &&\n                !this._rescc.public &&\n                !this._rescc.immutable)\n        ) {\n            return 0;\n        }\n\n        if (this._resHeaders.vary === '*') {\n            return 0;\n        }\n\n        if (this._isShared) {\n            if (this._rescc['proxy-revalidate']) {\n                return 0;\n            }\n            // if a response includes the s-maxage directive, a shared cache recipient MUST ignore the Expires field.\n            if (this._rescc['s-maxage']) {\n                return toNumberOrZero(this._rescc['s-maxage']);\n            }\n        }\n\n        // If a response includes a Cache-Control field with the max-age directive, a recipient MUST ignore the Expires field.\n        if (this._rescc['max-age']) {\n            return toNumberOrZero(this._rescc['max-age']);\n        }\n\n        const defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;\n\n        const serverDate = this.date();\n        if (this._resHeaders.expires) {\n            const expires = Date.parse(this._resHeaders.expires);\n            // A cache recipient MUST interpret invalid date formats, especially the value \"0\", as representing a time in the past (i.e., \"already expired\").\n            if (Number.isNaN(expires) || expires < serverDate) {\n                return 0;\n            }\n            return Math.max(defaultMinTtl, (expires - serverDate) / 1000);\n        }\n\n        if (this._resHeaders['last-modified']) {\n            const lastModified = Date.parse(this._resHeaders['last-modified']);\n            if (isFinite(lastModified) && serverDate > lastModified) {\n                return Math.max(\n                    defaultMinTtl,\n                    ((serverDate - lastModified) / 1000) * this._cacheHeuristic\n                );\n            }\n        }\n\n        return defaultMinTtl;\n    }\n\n    /**\n     * Remaining time this cache entry may be useful for, in *milliseconds*.\n     * You can use this as an expiration time for your cache storage.\n     *\n     * Prefer this method over `maxAge()`, because it includes other factors like `age` and `stale-while-revalidate`.\n     * @returns {number} Time-to-live in milliseconds.\n     */\n    timeToLive() {\n        const age = this.maxAge() - this.age();\n        const staleIfErrorAge = age + toNumberOrZero(this._rescc['stale-if-error']);\n        const staleWhileRevalidateAge = age + toNumberOrZero(this._rescc['stale-while-revalidate']);\n        return Math.round(Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1000);\n    }\n\n    /**\n     * If true, this cache entry is past its expiration date.\n     * Note that stale cache may be useful sometimes, see `evaluateRequest()`.\n     * @returns {boolean} `false` doesn't mean it's fresh nor usable\n     */\n    stale() {\n        return this.maxAge() <= this.age();\n    }\n\n    /**\n     * @returns {boolean} `true` if `stale-if-error` condition allows use of a stale response.\n     */\n    _useStaleIfError() {\n        return this.maxAge() + toNumberOrZero(this._rescc['stale-if-error']) > this.age();\n    }\n\n    /** See `evaluateRequest()` for a more complete solution\n     * @returns {boolean} `true` if `stale-while-revalidate` is currently allowed.\n     */\n    useStaleWhileRevalidate() {\n        const swr = toNumberOrZero(this._rescc['stale-while-revalidate']);\n        return swr > 0 && this.maxAge() + swr > this.age();\n    }\n\n    /**\n     * Creates a `CachePolicy` instance from a serialized object.\n     * @param {Object} obj - The serialized object.\n     * @returns {CachePolicy} A new CachePolicy instance.\n     */\n    static fromObject(obj) {\n        return new this(undefined, undefined, { _fromObject: obj });\n    }\n\n    /**\n     * @param {any} obj - The serialized object.\n     * @throws {Error} If already initialized or if the object is invalid.\n     */\n    _fromObject(obj) {\n        if (this._responseTime) throw Error('Reinitialized');\n        if (!obj || obj.v !== 1) throw Error('Invalid serialization');\n\n        this._responseTime = obj.t;\n        this._isShared = obj.sh;\n        this._cacheHeuristic = obj.ch;\n        this._immutableMinTtl =\n            obj.imm !== undefined ? obj.imm : 24 * 3600 * 1000;\n        this._ignoreCargoCult = !!obj.icc;\n        this._status = obj.st;\n        this._resHeaders = obj.resh;\n        this._rescc = obj.rescc;\n        this._method = obj.m;\n        this._url = obj.u;\n        this._host = obj.h;\n        this._noAuthorization = obj.a;\n        this._reqHeaders = obj.reqh;\n        this._reqcc = obj.reqcc;\n    }\n\n    /**\n     * Serializes the `CachePolicy` instance into a JSON-serializable object.\n     * @returns {Object} The serialized object.\n     */\n    toObject() {\n        return {\n            v: 1,\n            t: this._responseTime,\n            sh: this._isShared,\n            ch: this._cacheHeuristic,\n            imm: this._immutableMinTtl,\n            icc: this._ignoreCargoCult,\n            st: this._status,\n            resh: this._resHeaders,\n            rescc: this._rescc,\n            m: this._method,\n            u: this._url,\n            h: this._host,\n            a: this._noAuthorization,\n            reqh: this._reqHeaders,\n            reqcc: this._reqcc,\n        };\n    }\n\n    /**\n     * Headers for sending to the origin server to revalidate stale response.\n     * Allows server to return 304 to allow reuse of the previous response.\n     *\n     * Hop by hop headers are always stripped.\n     * Revalidation headers may be added or removed, depending on request.\n     * @param {HttpRequest} incomingReq - The incoming HTTP request.\n     * @returns {Record<string, string>} The headers for the revalidation request.\n     */\n    revalidationHeaders(incomingReq) {\n        this._assertRequestHasHeaders(incomingReq);\n        const headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);\n\n        // This implementation does not understand range requests\n        delete headers['if-range'];\n\n        if (!this._requestMatches(incomingReq, true) || !this.storable()) {\n            // revalidation allowed via HEAD\n            // not for the same resource, or wasn't allowed to be cached anyway\n            delete headers['if-none-match'];\n            delete headers['if-modified-since'];\n            return headers;\n        }\n\n        /* MUST send that entity-tag in any cache validation request (using If-Match or If-None-Match) if an entity-tag has been provided by the origin server. */\n        if (this._resHeaders.etag) {\n            headers['if-none-match'] = headers['if-none-match']\n                ? `${headers['if-none-match']}, ${this._resHeaders.etag}`\n                : this._resHeaders.etag;\n        }\n\n        // Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators. Clients MUST NOT use weak validators in other forms of request.\n        const forbidsWeakValidators =\n            headers['accept-ranges'] ||\n            headers['if-match'] ||\n            headers['if-unmodified-since'] ||\n            (this._method && this._method != 'GET');\n\n        /* SHOULD send the Last-Modified value in non-subrange cache validation requests (using If-Modified-Since) if only a Last-Modified value has been provided by the origin server.\n        Note: This implementation does not understand partial responses (206) */\n        if (forbidsWeakValidators) {\n            delete headers['if-modified-since'];\n\n            if (headers['if-none-match']) {\n                const etags = headers['if-none-match']\n                    .split(/,/)\n                    .filter(etag => {\n                        return !/^\\s*W\\//.test(etag);\n                    });\n                if (!etags.length) {\n                    delete headers['if-none-match'];\n                } else {\n                    headers['if-none-match'] = etags.join(',').trim();\n                }\n            }\n        } else if (\n            this._resHeaders['last-modified'] &&\n            !headers['if-modified-since']\n        ) {\n            headers['if-modified-since'] = this._resHeaders['last-modified'];\n        }\n\n        return headers;\n    }\n\n    /**\n     * Creates new CachePolicy with information combined from the previews response,\n     * and the new revalidation response.\n     *\n     * Returns {policy, modified} where modified is a boolean indicating\n     * whether the response body has been modified, and old cached body can't be used.\n     *\n     * @param {HttpRequest} request - The latest HTTP request asking for the cached entry.\n     * @param {HttpResponse} response - The latest revalidation HTTP response from the origin server.\n     * @returns {{policy: CachePolicy, modified: boolean, matches: boolean}} The updated policy and modification status.\n     * @throws {Error} If the response headers are missing.\n     */\n    revalidatedPolicy(request, response) {\n        this._assertRequestHasHeaders(request);\n\n        if (this._useStaleIfError() && isErrorResponse(response)) {\n          return {\n              policy: this,\n              modified: false,\n              matches: true,\n          };\n        }\n\n        if (!response || !response.headers) {\n            throw Error('Response headers missing');\n        }\n\n        // These aren't going to be supported exactly, since one CachePolicy object\n        // doesn't know about all the other cached objects.\n        let matches = false;\n        if (response.status !== undefined && response.status != 304) {\n            matches = false;\n        } else if (\n            response.headers.etag &&\n            !/^\\s*W\\//.test(response.headers.etag)\n        ) {\n            // \"All of the stored responses with the same strong validator are selected.\n            // If none of the stored responses contain the same strong validator,\n            // then the cache MUST NOT use the new response to update any stored responses.\"\n            matches =\n                this._resHeaders.etag &&\n                this._resHeaders.etag.replace(/^\\s*W\\//, '') ===\n                    response.headers.etag;\n        } else if (this._resHeaders.etag && response.headers.etag) {\n            // \"If the new response contains a weak validator and that validator corresponds\n            // to one of the cache's stored responses,\n            // then the most recent of those matching stored responses is selected for update.\"\n            matches =\n                this._resHeaders.etag.replace(/^\\s*W\\//, '') ===\n                response.headers.etag.replace(/^\\s*W\\//, '');\n        } else if (this._resHeaders['last-modified']) {\n            matches =\n                this._resHeaders['last-modified'] ===\n                response.headers['last-modified'];\n        } else {\n            // If the new response does not include any form of validator (such as in the case where\n            // a client generates an If-Modified-Since request from a source other than the Last-Modified\n            // response header field), and there is only one stored response, and that stored response also\n            // lacks a validator, then that stored response is selected for update.\n            if (\n                !this._resHeaders.etag &&\n                !this._resHeaders['last-modified'] &&\n                !response.headers.etag &&\n                !response.headers['last-modified']\n            ) {\n                matches = true;\n            }\n        }\n\n        const optionsCopy = {\n            shared: this._isShared,\n            cacheHeuristic: this._cacheHeuristic,\n            immutableMinTimeToLive: this._immutableMinTtl,\n            ignoreCargoCult: this._ignoreCargoCult,\n        };\n\n        if (!matches) {\n            return {\n                policy: new this.constructor(request, response, optionsCopy),\n                // Client receiving 304 without body, even if it's invalid/mismatched has no option\n                // but to reuse a cached body. We don't have a good way to tell clients to do\n                // error recovery in such case.\n                modified: response.status != 304,\n                matches: false,\n            };\n        }\n\n        // use other header fields provided in the 304 (Not Modified) response to replace all instances\n        // of the corresponding header fields in the stored response.\n        const headers = {};\n        for (const k in this._resHeaders) {\n            headers[k] =\n                k in response.headers && !excludedFromRevalidationUpdate[k]\n                    ? response.headers[k]\n                    : this._resHeaders[k];\n        }\n\n        const newResponse = Object.assign({}, response, {\n            status: this._status,\n            method: this._method,\n            headers,\n        });\n        return {\n            policy: new this.constructor(request, newResponse, optionsCopy),\n            modified: false,\n            matches: true,\n        };\n    }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}