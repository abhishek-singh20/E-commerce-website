{"ast":null,"code":"import _objectSpread from \"C:/Users/sakas/OneDrive/Desktop/gogo/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { V4MAPPED, ADDRCONFIG, ALL, promises as dnsPromises, lookup as dnsLookup } from 'node:dns';\nimport { promisify } from 'node:util';\nimport os from 'node:os';\nconst {\n  Resolver: AsyncResolver\n} = dnsPromises;\nconst kCacheableLookupCreateConnection = Symbol('cacheableLookupCreateConnection');\nconst kCacheableLookupInstance = Symbol('cacheableLookupInstance');\nconst kExpires = Symbol('expires');\nconst supportsALL = typeof ALL === 'number';\nconst verifyAgent = agent => {\n  if (!(agent && typeof agent.createConnection === 'function')) {\n    throw new Error('Expected an Agent instance as the first argument');\n  }\n};\nconst map4to6 = entries => {\n  for (const entry of entries) {\n    if (entry.family === 6) {\n      continue;\n    }\n    entry.address = \"::ffff:\".concat(entry.address);\n    entry.family = 6;\n  }\n};\nconst getIfaceInfo = () => {\n  let has4 = false;\n  let has6 = false;\n  for (const device of Object.values(os.networkInterfaces())) {\n    for (const iface of device) {\n      if (iface.internal) {\n        continue;\n      }\n      if (iface.family === 'IPv6') {\n        has6 = true;\n      } else {\n        has4 = true;\n      }\n      if (has4 && has6) {\n        return {\n          has4,\n          has6\n        };\n      }\n    }\n  }\n  return {\n    has4,\n    has6\n  };\n};\nconst isIterable = map => {\n  return Symbol.iterator in map;\n};\nconst ignoreNoResultErrors = dnsPromise => {\n  return dnsPromise.catch(error => {\n    if (error.code === 'ENODATA' || error.code === 'ENOTFOUND' || error.code === 'ENOENT' // Windows: name exists, but not this record type\n    ) {\n      return [];\n    }\n    throw error;\n  });\n};\nconst ttl = {\n  ttl: true\n};\nconst all = {\n  all: true\n};\nconst all4 = {\n  all: true,\n  family: 4\n};\nconst all6 = {\n  all: true,\n  family: 6\n};\nexport default class CacheableLookup {\n  constructor() {\n    let {\n      cache = new Map(),\n      maxTtl = Infinity,\n      fallbackDuration = 3600,\n      errorTtl = 0.15,\n      resolver = new AsyncResolver(),\n      lookup = dnsLookup\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.maxTtl = maxTtl;\n    this.errorTtl = errorTtl;\n    this._cache = cache;\n    this._resolver = resolver;\n    this._dnsLookup = lookup && promisify(lookup);\n    this.stats = {\n      cache: 0,\n      query: 0\n    };\n    if (this._resolver instanceof AsyncResolver) {\n      this._resolve4 = this._resolver.resolve4.bind(this._resolver);\n      this._resolve6 = this._resolver.resolve6.bind(this._resolver);\n    } else {\n      this._resolve4 = promisify(this._resolver.resolve4.bind(this._resolver));\n      this._resolve6 = promisify(this._resolver.resolve6.bind(this._resolver));\n    }\n    this._iface = getIfaceInfo();\n    this._pending = {};\n    this._nextRemovalTime = false;\n    this._hostnamesToFallback = new Set();\n    this.fallbackDuration = fallbackDuration;\n    if (fallbackDuration > 0) {\n      const interval = setInterval(() => {\n        this._hostnamesToFallback.clear();\n      }, fallbackDuration * 1000);\n\n      /* istanbul ignore next: There is no `interval.unref()` when running inside an Electron renderer */\n      if (interval.unref) {\n        interval.unref();\n      }\n      this._fallbackInterval = interval;\n    }\n    this.lookup = this.lookup.bind(this);\n    this.lookupAsync = this.lookupAsync.bind(this);\n  }\n  set servers(servers) {\n    this.clear();\n    this._resolver.setServers(servers);\n  }\n  get servers() {\n    return this._resolver.getServers();\n  }\n  lookup(hostname, options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    } else if (typeof options === 'number') {\n      options = {\n        family: options\n      };\n    }\n    if (!callback) {\n      throw new Error('Callback must be a function.');\n    }\n\n    // eslint-disable-next-line promise/prefer-await-to-then\n    this.lookupAsync(hostname, options).then(result => {\n      if (options.all) {\n        callback(null, result);\n      } else {\n        callback(null, result.address, result.family, result.expires, result.ttl, result.source);\n      }\n    }, callback);\n  }\n  async lookupAsync(hostname) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (typeof options === 'number') {\n      options = {\n        family: options\n      };\n    }\n    let cached = await this.query(hostname);\n    if (options.family === 6) {\n      const filtered = cached.filter(entry => entry.family === 6);\n      if (options.hints & V4MAPPED) {\n        if (supportsALL && options.hints & ALL || filtered.length === 0) {\n          map4to6(cached);\n        } else {\n          cached = filtered;\n        }\n      } else {\n        cached = filtered;\n      }\n    } else if (options.family === 4) {\n      cached = cached.filter(entry => entry.family === 4);\n    }\n    if (options.hints & ADDRCONFIG) {\n      const {\n        _iface\n      } = this;\n      cached = cached.filter(entry => entry.family === 6 ? _iface.has6 : _iface.has4);\n    }\n    if (cached.length === 0) {\n      const error = new Error(\"cacheableLookup ENOTFOUND \".concat(hostname));\n      error.code = 'ENOTFOUND';\n      error.hostname = hostname;\n      throw error;\n    }\n    if (options.all) {\n      return cached;\n    }\n    return cached[0];\n  }\n  async query(hostname) {\n    let source = 'cache';\n    let cached = await this._cache.get(hostname);\n    if (cached) {\n      this.stats.cache++;\n    }\n    if (!cached) {\n      const pending = this._pending[hostname];\n      if (pending) {\n        this.stats.cache++;\n        cached = await pending;\n      } else {\n        source = 'query';\n        const newPromise = this.queryAndCache(hostname);\n        this._pending[hostname] = newPromise;\n        this.stats.query++;\n        try {\n          cached = await newPromise;\n        } finally {\n          delete this._pending[hostname];\n        }\n      }\n    }\n    cached = cached.map(entry => {\n      return _objectSpread(_objectSpread({}, entry), {}, {\n        source\n      });\n    });\n    return cached;\n  }\n  async _resolve(hostname) {\n    // ANY is unsafe as it doesn't trigger new queries in the underlying server.\n    const [A, AAAA] = await Promise.all([ignoreNoResultErrors(this._resolve4(hostname, ttl)), ignoreNoResultErrors(this._resolve6(hostname, ttl))]);\n    let aTtl = 0;\n    let aaaaTtl = 0;\n    let cacheTtl = 0;\n    const now = Date.now();\n    for (const entry of A) {\n      entry.family = 4;\n      entry.expires = now + entry.ttl * 1000;\n      aTtl = Math.max(aTtl, entry.ttl);\n    }\n    for (const entry of AAAA) {\n      entry.family = 6;\n      entry.expires = now + entry.ttl * 1000;\n      aaaaTtl = Math.max(aaaaTtl, entry.ttl);\n    }\n    if (A.length > 0) {\n      if (AAAA.length > 0) {\n        cacheTtl = Math.min(aTtl, aaaaTtl);\n      } else {\n        cacheTtl = aTtl;\n      }\n    } else {\n      cacheTtl = aaaaTtl;\n    }\n    return {\n      entries: [...A, ...AAAA],\n      cacheTtl\n    };\n  }\n  async _lookup(hostname) {\n    try {\n      const [A, AAAA] = await Promise.all([\n      // Passing {all: true} doesn't return all IPv4 and IPv6 entries.\n      // See https://github.com/szmarczak/cacheable-lookup/issues/42\n      ignoreNoResultErrors(this._dnsLookup(hostname, all4)), ignoreNoResultErrors(this._dnsLookup(hostname, all6))]);\n      return {\n        entries: [...A, ...AAAA],\n        cacheTtl: 0\n      };\n    } catch (_unused) {\n      return {\n        entries: [],\n        cacheTtl: 0\n      };\n    }\n  }\n  async _set(hostname, data, cacheTtl) {\n    if (this.maxTtl > 0 && cacheTtl > 0) {\n      cacheTtl = Math.min(cacheTtl, this.maxTtl) * 1000;\n      data[kExpires] = Date.now() + cacheTtl;\n      try {\n        await this._cache.set(hostname, data, cacheTtl);\n      } catch (error) {\n        this.lookupAsync = async () => {\n          const cacheError = new Error('Cache Error. Please recreate the CacheableLookup instance.');\n          cacheError.cause = error;\n          throw cacheError;\n        };\n      }\n      if (isIterable(this._cache)) {\n        this._tick(cacheTtl);\n      }\n    }\n  }\n  async queryAndCache(hostname) {\n    if (this._hostnamesToFallback.has(hostname)) {\n      return this._dnsLookup(hostname, all);\n    }\n    let query = await this._resolve(hostname);\n    if (query.entries.length === 0 && this._dnsLookup) {\n      query = await this._lookup(hostname);\n      if (query.entries.length !== 0 && this.fallbackDuration > 0) {\n        // Use `dns.lookup(...)` for that particular hostname\n        this._hostnamesToFallback.add(hostname);\n      }\n    }\n    const cacheTtl = query.entries.length === 0 ? this.errorTtl : query.cacheTtl;\n    await this._set(hostname, query.entries, cacheTtl);\n    return query.entries;\n  }\n  _tick(ms) {\n    const nextRemovalTime = this._nextRemovalTime;\n    if (!nextRemovalTime || ms < nextRemovalTime) {\n      clearTimeout(this._removalTimeout);\n      this._nextRemovalTime = ms;\n      this._removalTimeout = setTimeout(() => {\n        this._nextRemovalTime = false;\n        let nextExpiry = Infinity;\n        const now = Date.now();\n        for (const [hostname, entries] of this._cache) {\n          const expires = entries[kExpires];\n          if (now >= expires) {\n            this._cache.delete(hostname);\n          } else if (expires < nextExpiry) {\n            nextExpiry = expires;\n          }\n        }\n        if (nextExpiry !== Infinity) {\n          this._tick(nextExpiry - now);\n        }\n      }, ms);\n\n      /* istanbul ignore next: There is no `timeout.unref()` when running inside an Electron renderer */\n      if (this._removalTimeout.unref) {\n        this._removalTimeout.unref();\n      }\n    }\n  }\n  install(agent) {\n    verifyAgent(agent);\n    if (kCacheableLookupCreateConnection in agent) {\n      throw new Error('CacheableLookup has been already installed');\n    }\n    agent[kCacheableLookupCreateConnection] = agent.createConnection;\n    agent[kCacheableLookupInstance] = this;\n    agent.createConnection = (options, callback) => {\n      if (!('lookup' in options)) {\n        options.lookup = this.lookup;\n      }\n      return agent[kCacheableLookupCreateConnection](options, callback);\n    };\n  }\n  uninstall(agent) {\n    verifyAgent(agent);\n    if (agent[kCacheableLookupCreateConnection]) {\n      if (agent[kCacheableLookupInstance] !== this) {\n        throw new Error('The agent is not owned by this CacheableLookup instance');\n      }\n      agent.createConnection = agent[kCacheableLookupCreateConnection];\n      delete agent[kCacheableLookupCreateConnection];\n      delete agent[kCacheableLookupInstance];\n    }\n  }\n  updateInterfaceInfo() {\n    const {\n      _iface\n    } = this;\n    this._iface = getIfaceInfo();\n    if (_iface.has4 && !this._iface.has4 || _iface.has6 && !this._iface.has6) {\n      this._cache.clear();\n    }\n  }\n  clear(hostname) {\n    if (hostname) {\n      this._cache.delete(hostname);\n      return;\n    }\n    this._cache.clear();\n  }\n}","map":{"version":3,"names":["V4MAPPED","ADDRCONFIG","ALL","promises","dnsPromises","lookup","dnsLookup","promisify","os","Resolver","AsyncResolver","kCacheableLookupCreateConnection","Symbol","kCacheableLookupInstance","kExpires","supportsALL","verifyAgent","agent","createConnection","Error","map4to6","entries","entry","family","address","concat","getIfaceInfo","has4","has6","device","Object","values","networkInterfaces","iface","internal","isIterable","map","iterator","ignoreNoResultErrors","dnsPromise","catch","error","code","ttl","all","all4","all6","CacheableLookup","constructor","cache","Map","maxTtl","Infinity","fallbackDuration","errorTtl","resolver","arguments","length","undefined","_cache","_resolver","_dnsLookup","stats","query","_resolve4","resolve4","bind","_resolve6","resolve6","_iface","_pending","_nextRemovalTime","_hostnamesToFallback","Set","interval","setInterval","clear","unref","_fallbackInterval","lookupAsync","servers","setServers","getServers","hostname","options","callback","then","result","expires","source","cached","filtered","filter","hints","get","pending","newPromise","queryAndCache","_objectSpread","_resolve","A","AAAA","Promise","aTtl","aaaaTtl","cacheTtl","now","Date","Math","max","min","_lookup","_unused","_set","data","set","cacheError","cause","_tick","has","add","ms","nextRemovalTime","clearTimeout","_removalTimeout","setTimeout","nextExpiry","delete","install","uninstall","updateInterfaceInfo"],"sources":["C:/Users/sakas/OneDrive/Desktop/gogo/node_modules/cacheable-lookup/source/index.js"],"sourcesContent":["import {\n\tV4MAPPED,\n\tADDRCONFIG,\n\tALL,\n\tpromises as dnsPromises,\n\tlookup as dnsLookup\n} from 'node:dns';\nimport {promisify} from 'node:util';\nimport os from 'node:os';\n\nconst {Resolver: AsyncResolver} = dnsPromises;\n\nconst kCacheableLookupCreateConnection = Symbol('cacheableLookupCreateConnection');\nconst kCacheableLookupInstance = Symbol('cacheableLookupInstance');\nconst kExpires = Symbol('expires');\n\nconst supportsALL = typeof ALL === 'number';\n\nconst verifyAgent = agent => {\n\tif (!(agent && typeof agent.createConnection === 'function')) {\n\t\tthrow new Error('Expected an Agent instance as the first argument');\n\t}\n};\n\nconst map4to6 = entries => {\n\tfor (const entry of entries) {\n\t\tif (entry.family === 6) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tentry.address = `::ffff:${entry.address}`;\n\t\tentry.family = 6;\n\t}\n};\n\nconst getIfaceInfo = () => {\n\tlet has4 = false;\n\tlet has6 = false;\n\n\tfor (const device of Object.values(os.networkInterfaces())) {\n\t\tfor (const iface of device) {\n\t\t\tif (iface.internal) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (iface.family === 'IPv6') {\n\t\t\t\thas6 = true;\n\t\t\t} else {\n\t\t\t\thas4 = true;\n\t\t\t}\n\n\t\t\tif (has4 && has6) {\n\t\t\t\treturn {has4, has6};\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {has4, has6};\n};\n\nconst isIterable = map => {\n\treturn Symbol.iterator in map;\n};\n\nconst ignoreNoResultErrors = dnsPromise => {\n\treturn dnsPromise.catch(error => {\n\t\tif (\n\t\t\terror.code === 'ENODATA' ||\n\t\t\terror.code === 'ENOTFOUND' ||\n\t\t\terror.code === 'ENOENT' // Windows: name exists, but not this record type\n\t\t) {\n\t\t\treturn [];\n\t\t}\n\n\t\tthrow error;\n\t});\n};\n\nconst ttl = {ttl: true};\nconst all = {all: true};\nconst all4 = {all: true, family: 4};\nconst all6 = {all: true, family: 6};\n\nexport default class CacheableLookup {\n\tconstructor({\n\t\tcache = new Map(),\n\t\tmaxTtl = Infinity,\n\t\tfallbackDuration = 3600,\n\t\terrorTtl = 0.15,\n\t\tresolver = new AsyncResolver(),\n\t\tlookup = dnsLookup\n\t} = {}) {\n\t\tthis.maxTtl = maxTtl;\n\t\tthis.errorTtl = errorTtl;\n\n\t\tthis._cache = cache;\n\t\tthis._resolver = resolver;\n\t\tthis._dnsLookup = lookup && promisify(lookup);\n\t\tthis.stats = {\n\t\t\tcache: 0,\n\t\t\tquery: 0\n\t\t};\n\n\t\tif (this._resolver instanceof AsyncResolver) {\n\t\t\tthis._resolve4 = this._resolver.resolve4.bind(this._resolver);\n\t\t\tthis._resolve6 = this._resolver.resolve6.bind(this._resolver);\n\t\t} else {\n\t\t\tthis._resolve4 = promisify(this._resolver.resolve4.bind(this._resolver));\n\t\t\tthis._resolve6 = promisify(this._resolver.resolve6.bind(this._resolver));\n\t\t}\n\n\t\tthis._iface = getIfaceInfo();\n\n\t\tthis._pending = {};\n\t\tthis._nextRemovalTime = false;\n\t\tthis._hostnamesToFallback = new Set();\n\n\t\tthis.fallbackDuration = fallbackDuration;\n\n\t\tif (fallbackDuration > 0) {\n\t\t\tconst interval = setInterval(() => {\n\t\t\t\tthis._hostnamesToFallback.clear();\n\t\t\t}, fallbackDuration * 1000);\n\n\t\t\t/* istanbul ignore next: There is no `interval.unref()` when running inside an Electron renderer */\n\t\t\tif (interval.unref) {\n\t\t\t\tinterval.unref();\n\t\t\t}\n\n\t\t\tthis._fallbackInterval = interval;\n\t\t}\n\n\t\tthis.lookup = this.lookup.bind(this);\n\t\tthis.lookupAsync = this.lookupAsync.bind(this);\n\t}\n\n\tset servers(servers) {\n\t\tthis.clear();\n\n\t\tthis._resolver.setServers(servers);\n\t}\n\n\tget servers() {\n\t\treturn this._resolver.getServers();\n\t}\n\n\tlookup(hostname, options, callback) {\n\t\tif (typeof options === 'function') {\n\t\t\tcallback = options;\n\t\t\toptions = {};\n\t\t} else if (typeof options === 'number') {\n\t\t\toptions = {\n\t\t\t\tfamily: options\n\t\t\t};\n\t\t}\n\n\t\tif (!callback) {\n\t\t\tthrow new Error('Callback must be a function.');\n\t\t}\n\n\t\t// eslint-disable-next-line promise/prefer-await-to-then\n\t\tthis.lookupAsync(hostname, options).then(result => {\n\t\t\tif (options.all) {\n\t\t\t\tcallback(null, result);\n\t\t\t} else {\n\t\t\t\tcallback(null, result.address, result.family, result.expires, result.ttl, result.source);\n\t\t\t}\n\t\t}, callback);\n\t}\n\n\tasync lookupAsync(hostname, options = {}) {\n\t\tif (typeof options === 'number') {\n\t\t\toptions = {\n\t\t\t\tfamily: options\n\t\t\t};\n\t\t}\n\n\t\tlet cached = await this.query(hostname);\n\n\t\tif (options.family === 6) {\n\t\t\tconst filtered = cached.filter(entry => entry.family === 6);\n\n\t\t\tif (options.hints & V4MAPPED) {\n\t\t\t\tif ((supportsALL && options.hints & ALL) || filtered.length === 0) {\n\t\t\t\t\tmap4to6(cached);\n\t\t\t\t} else {\n\t\t\t\t\tcached = filtered;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcached = filtered;\n\t\t\t}\n\t\t} else if (options.family === 4) {\n\t\t\tcached = cached.filter(entry => entry.family === 4);\n\t\t}\n\n\t\tif (options.hints & ADDRCONFIG) {\n\t\t\tconst {_iface} = this;\n\t\t\tcached = cached.filter(entry => entry.family === 6 ? _iface.has6 : _iface.has4);\n\t\t}\n\n\t\tif (cached.length === 0) {\n\t\t\tconst error = new Error(`cacheableLookup ENOTFOUND ${hostname}`);\n\t\t\terror.code = 'ENOTFOUND';\n\t\t\terror.hostname = hostname;\n\n\t\t\tthrow error;\n\t\t}\n\n\t\tif (options.all) {\n\t\t\treturn cached;\n\t\t}\n\n\t\treturn cached[0];\n\t}\n\n\tasync query(hostname) {\n\t\tlet source = 'cache';\n\t\tlet cached = await this._cache.get(hostname);\n\n\t\tif (cached) {\n\t\t\tthis.stats.cache++;\n\t\t}\n\n\t\tif (!cached) {\n\t\t\tconst pending = this._pending[hostname];\n\t\t\tif (pending) {\n\t\t\t\tthis.stats.cache++;\n\t\t\t\tcached = await pending;\n\t\t\t} else {\n\t\t\t\tsource = 'query';\n\t\t\t\tconst newPromise = this.queryAndCache(hostname);\n\t\t\t\tthis._pending[hostname] = newPromise;\n\t\t\t\tthis.stats.query++;\n\t\t\t\ttry {\n\t\t\t\t\tcached = await newPromise;\n\t\t\t\t} finally {\n\t\t\t\t\tdelete this._pending[hostname];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcached = cached.map(entry => {\n\t\t\treturn {...entry, source};\n\t\t});\n\n\t\treturn cached;\n\t}\n\n\tasync _resolve(hostname) {\n\t\t// ANY is unsafe as it doesn't trigger new queries in the underlying server.\n\t\tconst [A, AAAA] = await Promise.all([\n\t\t\tignoreNoResultErrors(this._resolve4(hostname, ttl)),\n\t\t\tignoreNoResultErrors(this._resolve6(hostname, ttl))\n\t\t]);\n\n\t\tlet aTtl = 0;\n\t\tlet aaaaTtl = 0;\n\t\tlet cacheTtl = 0;\n\n\t\tconst now = Date.now();\n\n\t\tfor (const entry of A) {\n\t\t\tentry.family = 4;\n\t\t\tentry.expires = now + (entry.ttl * 1000);\n\n\t\t\taTtl = Math.max(aTtl, entry.ttl);\n\t\t}\n\n\t\tfor (const entry of AAAA) {\n\t\t\tentry.family = 6;\n\t\t\tentry.expires = now + (entry.ttl * 1000);\n\n\t\t\taaaaTtl = Math.max(aaaaTtl, entry.ttl);\n\t\t}\n\n\t\tif (A.length > 0) {\n\t\t\tif (AAAA.length > 0) {\n\t\t\t\tcacheTtl = Math.min(aTtl, aaaaTtl);\n\t\t\t} else {\n\t\t\t\tcacheTtl = aTtl;\n\t\t\t}\n\t\t} else {\n\t\t\tcacheTtl = aaaaTtl;\n\t\t}\n\n\t\treturn {\n\t\t\tentries: [\n\t\t\t\t...A,\n\t\t\t\t...AAAA\n\t\t\t],\n\t\t\tcacheTtl\n\t\t};\n\t}\n\n\tasync _lookup(hostname) {\n\t\ttry {\n\t\t\tconst [A, AAAA] = await Promise.all([\n\t\t\t\t// Passing {all: true} doesn't return all IPv4 and IPv6 entries.\n\t\t\t\t// See https://github.com/szmarczak/cacheable-lookup/issues/42\n\t\t\t\tignoreNoResultErrors(this._dnsLookup(hostname, all4)),\n\t\t\t\tignoreNoResultErrors(this._dnsLookup(hostname, all6))\n\t\t\t]);\n\n\t\t\treturn {\n\t\t\t\tentries: [\n\t\t\t\t\t...A,\n\t\t\t\t\t...AAAA\n\t\t\t\t],\n\t\t\t\tcacheTtl: 0\n\t\t\t};\n\t\t} catch {\n\t\t\treturn {\n\t\t\t\tentries: [],\n\t\t\t\tcacheTtl: 0\n\t\t\t};\n\t\t}\n\t}\n\n\tasync _set(hostname, data, cacheTtl) {\n\t\tif (this.maxTtl > 0 && cacheTtl > 0) {\n\t\t\tcacheTtl = Math.min(cacheTtl, this.maxTtl) * 1000;\n\t\t\tdata[kExpires] = Date.now() + cacheTtl;\n\n\t\t\ttry {\n\t\t\t\tawait this._cache.set(hostname, data, cacheTtl);\n\t\t\t} catch (error) {\n\t\t\t\tthis.lookupAsync = async () => {\n\t\t\t\t\tconst cacheError = new Error('Cache Error. Please recreate the CacheableLookup instance.');\n\t\t\t\t\tcacheError.cause = error;\n\n\t\t\t\t\tthrow cacheError;\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (isIterable(this._cache)) {\n\t\t\t\tthis._tick(cacheTtl);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync queryAndCache(hostname) {\n\t\tif (this._hostnamesToFallback.has(hostname)) {\n\t\t\treturn this._dnsLookup(hostname, all);\n\t\t}\n\n\t\tlet query = await this._resolve(hostname);\n\n\t\tif (query.entries.length === 0 && this._dnsLookup) {\n\t\t\tquery = await this._lookup(hostname);\n\n\t\t\tif (query.entries.length !== 0 && this.fallbackDuration > 0) {\n\t\t\t\t// Use `dns.lookup(...)` for that particular hostname\n\t\t\t\tthis._hostnamesToFallback.add(hostname);\n\t\t\t}\n\t\t}\n\n\t\tconst cacheTtl = query.entries.length === 0 ? this.errorTtl : query.cacheTtl;\n\t\tawait this._set(hostname, query.entries, cacheTtl);\n\n\t\treturn query.entries;\n\t}\n\n\t_tick(ms) {\n\t\tconst nextRemovalTime = this._nextRemovalTime;\n\n\t\tif (!nextRemovalTime || ms < nextRemovalTime) {\n\t\t\tclearTimeout(this._removalTimeout);\n\n\t\t\tthis._nextRemovalTime = ms;\n\n\t\t\tthis._removalTimeout = setTimeout(() => {\n\t\t\t\tthis._nextRemovalTime = false;\n\n\t\t\t\tlet nextExpiry = Infinity;\n\n\t\t\t\tconst now = Date.now();\n\n\t\t\t\tfor (const [hostname, entries] of this._cache) {\n\t\t\t\t\tconst expires = entries[kExpires];\n\n\t\t\t\t\tif (now >= expires) {\n\t\t\t\t\t\tthis._cache.delete(hostname);\n\t\t\t\t\t} else if (expires < nextExpiry) {\n\t\t\t\t\t\tnextExpiry = expires;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (nextExpiry !== Infinity) {\n\t\t\t\t\tthis._tick(nextExpiry - now);\n\t\t\t\t}\n\t\t\t}, ms);\n\n\t\t\t/* istanbul ignore next: There is no `timeout.unref()` when running inside an Electron renderer */\n\t\t\tif (this._removalTimeout.unref) {\n\t\t\t\tthis._removalTimeout.unref();\n\t\t\t}\n\t\t}\n\t}\n\n\tinstall(agent) {\n\t\tverifyAgent(agent);\n\n\t\tif (kCacheableLookupCreateConnection in agent) {\n\t\t\tthrow new Error('CacheableLookup has been already installed');\n\t\t}\n\n\t\tagent[kCacheableLookupCreateConnection] = agent.createConnection;\n\t\tagent[kCacheableLookupInstance] = this;\n\n\t\tagent.createConnection = (options, callback) => {\n\t\t\tif (!('lookup' in options)) {\n\t\t\t\toptions.lookup = this.lookup;\n\t\t\t}\n\n\t\t\treturn agent[kCacheableLookupCreateConnection](options, callback);\n\t\t};\n\t}\n\n\tuninstall(agent) {\n\t\tverifyAgent(agent);\n\n\t\tif (agent[kCacheableLookupCreateConnection]) {\n\t\t\tif (agent[kCacheableLookupInstance] !== this) {\n\t\t\t\tthrow new Error('The agent is not owned by this CacheableLookup instance');\n\t\t\t}\n\n\t\t\tagent.createConnection = agent[kCacheableLookupCreateConnection];\n\n\t\t\tdelete agent[kCacheableLookupCreateConnection];\n\t\t\tdelete agent[kCacheableLookupInstance];\n\t\t}\n\t}\n\n\tupdateInterfaceInfo() {\n\t\tconst {_iface} = this;\n\n\t\tthis._iface = getIfaceInfo();\n\n\t\tif ((_iface.has4 && !this._iface.has4) || (_iface.has6 && !this._iface.has6)) {\n\t\t\tthis._cache.clear();\n\t\t}\n\t}\n\n\tclear(hostname) {\n\t\tif (hostname) {\n\t\t\tthis._cache.delete(hostname);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._cache.clear();\n\t}\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}